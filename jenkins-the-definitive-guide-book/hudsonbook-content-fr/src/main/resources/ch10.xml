<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="chapter-advanced-builds">
  <title>Builds avancés</title>
  <sect1 id="sect-advanced-builds-introduction">
    <title>Introduction</title>
    <para>Dans ce chapitre, nous regarderons quelques configurations avancées
    de tâches de build. Nous traiterons des builds paramétrés, qui permettent
    à Jenkins de demander à l'utilisateur des paramètres supplémentaires qui
    seront passés à la tâche de build, et des tâches de build
    multiconfigurations, qui vous permettent d'exécuter une simple tâche selon
    de nombreuses variations. Nous verrons comment exécuter les tâches en
    parallèle, et comment attendre le résultat d'une ou plusieurs tâches avant de
    continuer. Nous verrons enfin comment implémenter des stratégies de
    promotion de build et de pipelines de build afin de pouvoir utiliser
    Jenkins non seulement comme un serveur de build, mais aussi comme un
    serveur de déploiement.</para>
  </sect1>
  <sect1 id="sect-advanced-builds-parameterized">
    <title>Tâches de build paramétrées</title>
    <para>Les builds<indexterm class="startofrange" id="ch10-param1"
        significance="normal">
        <primary>tâches de build</primary>
        <secondary>paramétrées</secondary>
      </indexterm><indexterm class="startofrange" id="ch10-param2"
        significance="normal">
        <primary>tâches de build paramétrées</primary>
      </indexterm> paramétrés sont un concept puissant vous permettant
    d'ajouter une nouvelle dimension à vos tâches de build.</para>
    <para>Le plugin <indexterm id="I_indexterm10_d1e13891"
        significance="normal">
        <primary>plugins</primary>
        <secondary>Parameterized Build</secondary>
      </indexterm><indexterm id="I_indexterm10_d1e13896" significance="normal">
        <primary>le plugin Parameterized Build</primary>
      </indexterm> Parameterized Build vous permet de configurer des
    paramètres pour vos tâches de build, qui peuvent être entrés par
    l'utilisateur lorsque le build est déclenché, ou (comme nous le verrons
    plus tard) depuis une autre tâche.</para>
    <para>Par exemple, vous pourriez avoir une tâche de déploiement, où vous
    choisiriez un environnement cible dans une liste déroulante quand vous
    démarrez le build. Vous pourriez aussi vouloir spécifier la version de
    l'application que vous souhaitez déployer. Ou, en exécutant une tâche de
    build incluant des tests web, vous pourriez spécifier le navigateur dans
    lequel vous voulez faire tourner vos tests Selenium ou WebDriver. Vous 
	pouvez même télétransférer un fichier nécessaire à l'exécution de la tâche
	de build.</para>
    <para>Notez que c'est le rôle du script de build d'analyser et de traiter
    correctement les valeurs de paramètres — Jenkins fournit simplement une
    interface utilisateur permettant d'entrer les valeurs des paramètres, puis
    de passer ces paramètres au script de build.</para>
    <sect2>
      <title>Créer des tâches de build paramétrées</title>
      <para>Vous <indexterm id="I_indexterm10_d1e13909" significance="normal">
          <primary>tâches de build</primary>
          <secondary>paramétrées</secondary>
          <tertiary>créer</tertiary>
        </indexterm><indexterm id="I_indexterm10_d1e13916"
          significance="normal">
          <primary>tâches de build paramétrées</primary>
          <secondary>créer</secondary>
        </indexterm> installez le plugin Parameterized Build comme d'habitude,
      via l'écran de gestion des plugins. Une fois que vous avez fait cela,
      configurer une tâche de build paramétrée est simple. Cochez simplement
      l'option “Ce build a des paramètres” et cliquez sur Ajouter un paramètre
      pour ajouter un nouveau paramètre de tâche de build (voir <xref
      linkend="fig-hudson-parameterized-build" />). Vous pouvez ajouter des
      paramètres à n'importe quelle sorte de build, et vous pouvez ajouter
      autant de paramètres que vous voulez à une tâche de build donnée.</para>
      <figure float="none" id="fig-hudson-parameterized-build">
        <title>Créer une tâche de build paramétrée</title>
        <mediaobject id="I_mediaobject10_d1e13927">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1001.pdf" format="PDF"
                       scale="90" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1001.png" format="PNG"
                       scale="90" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Pour ajouter un paramètre à votre tâche de build, sélectionnez
      simplement le type de paramètre dans la liste déroulante. Cela vous
      permettra de configurer les détails de votre paramètre (voir <xref
      linkend="fig-hudson-string-build-parameter" />). Vous pouvez choisir
      différents <indexterm id="I_indexterm10_d1e13936" significance="normal">
          <primary>tâches de build paramétrées</primary>
          <secondary>types de paramètres</secondary>
        </indexterm><indexterm id="I_indexterm10_d1e13941"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>parametré</secondary>
          <tertiary>types de paramètres</tertiary>
        </indexterm><indexterm id="I_indexterm10_d1e13948"
          significance="normal">
          <primary>paramètres chaînes</primary>
        </indexterm>types de paramètres, comme des chaînes de caractères, des
      booléens, et des listes déroulantes. En fonction du type que vous
      choisissez, vous devrez entrer des valeurs de configuration légèrement
      différentes, mais le processus de base est le même. Tous les types de
      paramètres, à l'exception du paramètre Fichier, ont un nom et une
      description, et le plus souvent une valeur par défaut.</para>
      <para>Dans <xref linkend="fig-hudson-enter-string-parameter" />, par
      exemple, nous ajoutons un paramètre appelé <literal
      moreinfo="none">version</literal> à une tâche de déploiement. La valeur
      par défaut (<literal moreinfo="none">RELEASE</literal>) sera
      initialement affichée lorsque Jenkins demandera à l'utilisateur de
      valoriser ce paramètre, donc si l'utilisateur ne change rien, cette
      valeur sera utilisée.</para>
      <figure float="0" id="fig-hudson-string-build-parameter">
        <title>Ajouter un paramètre à la tâche de build</title>
        <mediaobject id="I_mediaobject10_d1e13965">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1002.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1002.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Quand l'utilisateur démarre un build paramétré (les builds
      paramétrés sont très souvent démarrées manuellement), Jenkins propose
      une page dans laquelle l'utilisateur peut entrer une valeur pour chacun
      des paramètres de la tâche de build (voir <xref
      linkend="fig-hudson-enter-string-parameter" />).</para>
      <figure float="0" id="fig-hudson-enter-string-parameter">
        <title>Ajouter un paramètre à la tâche de build</title>
        <mediaobject id="I_mediaobject10_d1e13977">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1003.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1003.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
    <sect2>
      <title>Adapter vos build pour travailler avec des scripts de builds
      paramétrés</title>
      <para>Une fois<indexterm class="startofrange" id="ch10-script"
          significance="normal">
          <primary>scripts</primary>
          <secondary>paramétrés</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-script2"
          significance="normal">
          <primary>tâches de build paramétrées</primary>
          <secondary>scripts de build pour</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-script3"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>paramétrées</secondary>
          <tertiary>tâches de build paramétrées</tertiary>
        </indexterm><indexterm id="I_indexterm10_d1e14004"
          significance="normal">
          <primary>scripts de build</primary>
          <see>scripts</see>
        </indexterm> que vous avez ajouté un paramètre, vous devez configurer
      vos scripts de build pour l'utiliser. Bien choisir le nom du paramètre
      est important, parce que c'est aussi le nom de la variable que Jenkins
      passera comme <indexterm id="I_indexterm10_d1e14010"
          significance="normal">
          <primary>variables d'environnement</primary>
          <secondary>paramètres de build comme</secondary>
        </indexterm>variable d'environnement lorsqu'il lance la tâche de
      build. Pour illustrer cela, considérons la configuration de build très
      basique de <xref linkend="fig-hudson-parameterized-shell" />, où on
      affiche simplement le paramètre de build en retour dans la console.
      Notez que, pour rendre les variables plus portables à travers différents
      systèmes d'exploitation, il est préférable de les mettre en
      majuscules.</para>
      <figure float="0" id="fig-hudson-parameterized-shell">
        <title>Démonstration d'un paramètre de build</title>
        <mediaobject id="I_mediaobject10_d1e14021">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1004.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1004.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Quand on exécute cela, on obtient les lignes suivantes dans la
      console :</para>
      <screen format="linespecific">Started by user anonymous
Building on master
[workspace] $ /bin/sh -xe /var/folders/y+/y+a+wZ-jG6WKHEm9KwnSvE+++TI/-Tmp-/
jenkins5862957776458050998.sh
<userinput moreinfo="none">+ echo Version=1.2.3</userinput>
<userinput moreinfo="none">Version=1.2.3</userinput>
Notifying upstream projects of job completion
Finished: SUCCESS</screen>
      <para>Vous pouvez aussi utiliser ces variables d'environnement au
      sein de vos scripts de build. Par exemple, dans un build Ant ou
      Maven, vous pouvez utiliser la propriété spéciale <literal
      moreinfo="none">env</literal> pour accéder aux variables d'environnement
      courantes :</para>
      <programlisting format="linespecific" id="I_programlisting10_d1e14041">&lt;target name="printversion"&gt;
  &lt;property environment="env" /&gt;
  &lt;echo message="${env.VERSION}"/&gt;
&lt;/target&gt;</programlisting>
      <para>Une autre option consiste à passer les <indexterm
          id="I_indexterm10_d1e14045" significance="normal">
          <primary>propriétés</primary>
          <secondary>paramètres de build comme</secondary>
        </indexterm>paramètres au script de build comme une valeur de
      propriété. Ce qui suit est un exemple plus pratique d'un fichier POM de
      Maven. Dans cet exemple, Maven est configuré pour déployer un fichier
      WAR spécifique. Nous fournissons la version du fichier WAR à déployer
      dans la propriété <literal moreinfo="none">target.version</literal>, qui
      est utilisé dans la déclaration de la dépendance, comme montré
      ci-dessous :</para>
      <programlisting format="linespecific" id="I_programlisting10_d1e14054">  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.wakaleo.gameoflife&lt;/groupId&gt;
      &lt;artifactId&gt;gameoflife-web&lt;/artifactId&gt;
      &lt;type&gt;war&lt;/type&gt;
      &lt;version&gt;<userinput moreinfo="none">${target.version}</userinput>&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;properties&gt;
    &lt;target.version&gt;RELEASE&lt;/target.version&gt;
    ...
  &lt;/properties&gt;</programlisting>
      <para>Quand on invoque Maven, on passe le paramètre comme l'une des
      propriétés du build (voir <xref
      linkend="fig-hudson-inject-parameter-maven" />). On peut ensuite
      utiliser un outil comme Cargo pour faire le déploiement réel — Maven
      téléchargera la version demandée du WAR depuis le gestionnaire de dépôt
      d'entreprise, et la déploiera sur un serveur d'application.</para>
      <figure float="none" id="fig-hudson-inject-parameter-maven">
        <title>Ajouter un paramètre à la tâche de build Maven</title>
        <mediaobject id="I_mediaobject10_d1e14066">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1005.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1005.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>En résumé, cela montre comment il vous est possible d'intégrer des
      paramètres de tâches de build dans vos builds. Toutefois, en plus des bons vieux
      paramètres de type chaîne de caractères, il existe quelques
      types de paramètres plus sophistiqués, que nous regarderons dans les
      <indexterm class="endofrange" id="I_indexterm10_d1e14074"
          significance="normal" startref="ch10-script">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14076"
          significance="normal" startref="ch10-script2">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14078"
          significance="normal" startref="ch10-script3">
          <primary></primary>
        </indexterm>paragraphes suivants (voir <xref
      linkend="fig-hudson-build-parameter-types" />).</para>
      <figure float="0" id="fig-hudson-build-parameter-types">
        <title>Différents types de paramètres sont disponibles</title>
        <mediaobject id="I_mediaobject10_d1e14086">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1006.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1006.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
    <sect2>
      <title>Types de paramètres plus avancés</title>
      <para><firstterm>Les paramètres Mot de passe</firstterm> <indexterm
          id="I_indexterm10_d1e14098" significance="normal">
          <primary>paramètres Mot de passe</primary>
        </indexterm><indexterm class="startofrange" id="ch10-type1"
          significance="normal">
          <primary>tâches de build paramétrées</primary>
          <secondary>types des paramètres</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-type2"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>paramétrées</secondary>
          <tertiary>types des paramètres</tertiary>
        </indexterm>sont, comme vous pourriez vous y attendre, très similaires
      aux paramètres String, mis à part qu'ils sont affichés comme des champs
      mot de passe.</para>
      <para>Il existe plusieurs cas où vous souhaiteriez présenter un ensemble
      limité d'options de paramètres. Dans un build de déploiement, vous
      pourriez permettre à l'utilisateur de choisir parmi un ensemble
      de serveurs cibles. Ou vous pourriez présenter une liste de navigateurs
      supportés pour une suite de tests d'acceptation. <firstterm>Les
      paramètres Choix</firstterm> vous permettent de définir un ensemble de
      valeurs qui seront affichées dans une liste déroulante (voir <xref
      linkend="fig-hudson-build-parameter-choice" />). Vous devez fournir une
      liste de valeurs possibles, une par ligne, en commençant par la valeur
      par défaut.</para>
      <figure float="none" id="fig-hudson-build-parameter-choice">
        <title>Configurer un paramètre Choix</title>
        <mediaobject id="I_mediaobject10_d1e14124">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1007.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1007.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para><firstterm>Les paramètres Booléen</firstterm> <indexterm
          id="I_indexterm10_d1e14133" significance="normal">
          <primary>paramètres Booléen</primary>
        </indexterm>sont, comme vous vous y attendez, des paramètres qui
      prennent comme valeur <literal moreinfo="none">true</literal> ou <literal
      moreinfo="none">false</literal>. Ils sont présentés en tant que case à
      cocher.</para>
      <para>Deux types de paramètres plus exotiques, qui se comportent un peu
      différemment des autres, sont les <firstterm>paramètres Run</firstterm>
      et <firstterm>les paramètres Fichier</firstterm>.</para>
      <para>Les paramètres Run <indexterm id="I_indexterm10_d1e14153"
          significance="normal">
          <primary>paramètres Run</primary>
        </indexterm><indexterm id="I_indexterm10_d1e14156"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>numéro d'exécution pour, en tant que
          paramètres</secondary>
        </indexterm>vous permettent de sélectionner une exécution particulière
      (ou un build) d'un build donné (voir <xref
      linkend="fig-hudson-build-parameter-run-param" />). L'utilisateur
      effectue une sélection à partir d'une liste de numéros d'exécution de
      build. L'URL correspondant à l'exécution est stockée dans le paramètre
      spécifié.</para>
      <figure float="none" id="fig-hudson-build-parameter-run-param">
        <title>Configurer un paramètre Run</title>
        <mediaobject id="I_mediaobject10_d1e14167">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1008.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1008.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>L'URL (qui devrait ressembler à
      <emphasis>http://jenkins.myorg.com/job/game-of-life/197/</emphasis>)
      peut être utilisée pour obtenir une information ou des artefacts d'une
      exécution de build. Par exemple, vous pourriez récupérer le fichier JAR
      ou WAR archivé lors d'un build précédent et exécuter des tests plus
      poussés sur celui-ci dans une tâche de build séparée. Ainsi, pour
      accéder au fichier WAR d'un build précédent dans un projet Maven
      multimodules, l'URL ressemblerait à celle-ci :</para>
      <programlisting format="linespecific" id="I_programlisting10_d1e14177">http://buildserver/job/game-of-life/197/artifact/gameoflife-web/target/
      gameoflife.war</programlisting>
      <para>Donc, en utilisant le paramètre configuré dans <xref
      linkend="fig-hudson-build-parameter-run-param" />, vous pourriez accéder
      au fichier WAR en utilisant l'expression suivante :</para>
      <programlisting format="linespecific" id="I_programlisting10_d1e14184">${RELEASE_BUILD}gameoflife-web/target/gameoflife.war</programlisting>
      <para>Les paramètres Fichier <indexterm
          id="I_indexterm10_d1e14188" significance="normal">
          <primary>paramètres Fichier</primary>
        </indexterm>vous permettent de télétransférer un fichier dans l'espace de
      travail de la tâche de build, afin qu'il puisse être utilisé dans le
      script de build (voir <xref
      linkend="fig-hudson-build-parameter-file" />). Jenkins stockera le
      fichier à l'emplacement spécifié dans l'espace de travail du projet, où
      vous pouvez y accéder dans vos scripts de build. Vous pouvez utiliser la
      variable <literal moreinfo="none">WORKSPACE</literal> pour faire
      référence au répertoire de l'espace de travail courant, afin que vous
      puissiez manipuler le fichier télétransferé dans <xref
      linkend="fig-hudson-build-parameter-file" /> en utilisant l'<indexterm
          class="endofrange" id="I_indexterm10_d1e14199" significance="normal"
          startref="ch10-type1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14201"
          significance="normal" startref="ch10-type2">
          <primary></primary>
        </indexterm>expression <literal
      moreinfo="none">${WORKSPACE}/deploy/app.war</literal>.</para>
      <figure float="none" id="fig-hudson-build-parameter-file">
        <title>Configurer un paramètre Fichier</title>
        <mediaobject id="I_mediaobject10_d1e14211">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1009.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1009.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
    <sect2 id="sect-build-from-svn-tag">
      <title>Construire à partir d'un tag Subversion</title>
      <para>Le <indexterm class="startofrange" id="ch10-sub1"
          significance="normal">
          <primary>tâches de build paramétrées</primary>
          <secondary>exécutées sur un tag Subversion</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-sub2"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>paramétrées</secondary>
          <tertiary>exécutées sur un tag subversion</tertiary>
        </indexterm><indexterm class="startofrange" id="ch10-sub3"
          significance="normal">
          <primary>Subversion</primary>
          <secondary>tags, build à partir de</secondary>
        </indexterm> déclenchement paramétré possède un support spécial
      pour Subversion, vous permettant ainsi de réaliser un build à partir d'un tag
      Subversion spécifique. C'est utile si vous voulez lancer un build de
      release en utilisant un tag généré par un build précédent. Par exemple,
      une tâche de build amont pourrait créer un tag d'une révision
      particulière. Vous pourriez aussi utiliser le processus standard de
      release Maven (voir <xref linkend="jenkins-maven-releases" />) pour
      générer une nouvelle release. Dans ce cas, un tag avec le numéro de
      release Maven sera automatiquement généré dans Subversion.</para>
      <para>Cette approche est utile pour des projets qui ont besoin d'être
      partiellement ou entièrement reconstruits avant de pouvoir être déployés
      sur une plateforme donnée. Par exemple, vous pourriez avoir besoin
      d'exécuter le build Ant ou Maven en utilisant différentes propriétés ou
      profils pour différentes plateformes, afin que les fichiers de
      configuration spécifiques puissent être embarqués dans les WAR ou EAR
      déployés.</para>
      <para>Vous pouvez configurer un build Jenkins pour qu'il s'exécute sur
      un tag sélectionné en utilisant le type de paramètre “List Subversion
      Tag” (voir <xref linkend="fig-jenkins-parameterized-subversion-tag" />).
      Vous devez simplement fournir l'URL du dépôt Subversion pointant sur le
      répertoire des tags de votre projet.</para>
      <figure float="none" id="fig-jenkins-parameterized-subversion-tag">
        <title>Ajouter des paramètres pour réaliser un build à partir d'un tag
        Subversion</title>
        <mediaobject id="I_mediaobject10_d1e14250">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1010.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1010.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Quand vous exécuterez ce build, Jenkins proposera une liste de
      tags dans laquelle choisir <indexterm class="endofrange"
          id="I_indexterm10_d1e14257" significance="normal"
          startref="ch10-sub1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14259"
          significance="normal" startref="ch10-sub2">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14261"
          significance="normal" startref="ch10-sub3">
          <primary></primary>
        </indexterm> (voir <xref
      linkend="fig-jenkins-parameterized-subversion" />).</para>
      <figure float="none" id="fig-jenkins-parameterized-subversion">
        <title>Réaliser un build à partir d'un tag Subversion</title>
        <mediaobject id="I_mediaobject10_d1e14269">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1011.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1011.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
    <sect2 id="sect-building-git-tag">
      <title>Réaliser un build à partir d'un tag Git</title>
      <para>Réaliser un build <indexterm class="startofrange" id="ch10-git1"
          significance="normal">
          <primary>tâches de build paramétrées</primary>
          <secondary>exécutées sur un tag Git</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-git2"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>paramétrées</secondary>
          <tertiary>exécutées sur un tag Git</tertiary>
        </indexterm><indexterm class="startofrange" id="ch10-git3"
          significance="normal">
          <primary>Git</primary>
          <secondary>tags, exécuter sur</secondary>
        </indexterm>à partir d'un tag Git n'est pas aussi simple que de le
      faire à partir d'un tag Subversion, bien que vous puissisez toujours
      utiliser un paramètre pour indiquer quel tag utiliser. En effet, à cause
      de la nature même de Git, quand Jenkins obtient une copie du code source
      depuis Git, il clone le dépôt Git, en incluant tous les tags. Une fois
      que vous avez la dernière version du dépôt sur votre serveur Jenkins,
      vous pouvez ensuite procéder à la récupération d'une version en
      utilisant <literal moreinfo="none">git checkout
      &lt;tagname&gt;</literal>.</para>
      <para>Pour configurer cela avec Jenkins, vous devez commencer par
      ajouter un paramètre String à votre tâche de build (appelée <literal
      moreinfo="none">RELEASE</literal> dans cet exemple — voir <xref
      linkend="fig-jenkins-git-release-param" />). Contrairement au support
      Subversion, il n'est pas possible de lister les tags Git disponibles
      dans une liste déroulante, les utilisateur devront donc connaître le nom
      du tag qu'ils veulent livrer.</para>
      <figure float="none" id="fig-jenkins-git-release-param">
        <title>Configurer un paramètre pour un tag Git</title>
        <mediaobject id="I_mediaobject10_d1e14310">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1012.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1012.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Une fois que vous avez ajouté ce paramètre, vous devez faire un
      checkout du tag correspondant une fois que le dépôt a été cloné localement.
      Ainsi, si vous avez un build freestyle, la première étape du build sera
      un appel en ligne de commande à Git pour faire un checkout du tag
      référencé par le paramètre <literal moreinfo="none">RELEASE</literal>
      (voir <xref linkend="fig-jenkins-git-tag" />). Bien sûr, un moyen plus
      portable de faire cela serait d'écrire un simple script Ant ou Groovy
      pour faire l'équivalent d'une façon plus<indexterm class="endofrange"
          id="I_indexterm10_d1e14322" significance="normal"
          startref="ch10-git1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14324"
          significance="normal" startref="ch10-git2">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14326"
          significance="normal" startref="ch10-git3">
          <primary></primary>
        </indexterm> indépendante du système d'exploitation.</para>
      <figure float="0" id="fig-jenkins-git-tag">
        <title>Réaliser un build à partir d'un tag Git</title>
        <mediaobject id="I_mediaobject10_d1e14332">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1013.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1013.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
    <sect2>
      <title>Démarrer une tâche de build paramétrée à distance</title>
      <para>Vous <indexterm class="startofrange" id="ch10-remote1"
          significance="normal">
          <primary>tâches de build paramétrées</primary>
          <secondary>démarrage à distance</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-remote2"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>paramétrées</secondary>
          <tertiary>démarrées à distance</tertiary>
        </indexterm>pouvez aussi démarrer une tâche de build paramétrée à
      distance, en invoquant l'URL de la tâche de build. La forme typique
      d'une URL de tâche de build est illustrée ci-après :</para>
      <programlisting format="linespecific" id="I_programlisting10_d1e14355">http://jenkins.acme.org/job/myjob/buildWithParameters?PARAMETER=Value</programlisting>
      <para>Ainsi, dans l'exemple ci-dessus, vous pourriez déclencher un build
      de la façon suivante :</para>
      <programlisting format="linespecific" id="I_programlisting10_d1e14359">http://jenkins.acme.org/job/parameterized-build/buildWithParameters?VERSION=1.2.3</programlisting>
      <para>Quand vous utilisez une URL pour démarrer une tâche de build de
      cette façon, rappelez-vous que les noms des paramètres sont sensibles à
      la casse, et que les valeurs doivent être échappées (comme n'importe
      quel autre paramètre HTTP). Et si vous utilisez un paramètre Run, vous
      devez fournir le nom de la tâche de build <emphasis>et</emphasis> le
      numéro d'exécution (e.g., <literal
      moreinfo="none">game-of-life#197</literal>) et pas seulement le
      numéro<indexterm class="endofrange" id="I_indexterm10_d1e14369"
          significance="normal" startref="ch10-remote1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14371"
          significance="normal" startref="ch10-remote2">
          <primary></primary>
        </indexterm> <phrase role="keep-together">d'exécution</phrase>.</para>
    </sect2>
    <sect2>
      <title>Historique des tâches de build paramétrées</title>
      <para>Enfin, <indexterm id="I_indexterm10_d1e14383"
          significance="normal">
          <primary>tâches de build paramétrées</primary>
          <secondary>historique de</secondary>
        </indexterm><indexterm id="I_indexterm10_d1e14388"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>paramétrées</secondary>
          <tertiary>historique de</tertiary>
        </indexterm><indexterm id="I_indexterm10_d1e14395"
          significance="normal">
          <primary>historique de build</primary>
          <secondary>paramétré</secondary>
        </indexterm>il est indispensable de savoir quels paramètres ont été
      utilisés pour lancer un build paramétré particulier. Par exemple, dans
      une tâche de build de déploiement automatisé, il est utile de savoir
      exactement quelle version a réellement été déployée. Heureusement,
      Jenkins stocke ces valeurs dans l'historique de<indexterm
          class="endofrange" id="I_indexterm10_d1e14401" significance="normal"
          startref="ch10-param1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14403"
          significance="normal" startref="ch10-param2">
          <primary></primary>
        </indexterm> build (voir <xref
      linkend="fig-hudson-build-parameter-history" />), afin que vous puissiez
      toujours retrouver un ancien build et en vérifier les paramètres.</para>
      <figure float="none" id="fig-hudson-build-parameter-history">
        <title>Jenkins stocke les valeurs des paramètres utilisées pour chaque
        build</title>
        <mediaobject id="I_mediaobject10_d1e14411">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1014.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1014.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
  </sect1>
  <sect1 id="sect-advanced-builds-triggers">
    <title>Déclencheurs paramétrés</title>
    <para>Quand <indexterm class="startofrange" id="ch10-trig1"
        significance="normal">
        <primary>déclencheurs paramétrés</primary>
      </indexterm><indexterm class="startofrange" id="ch10-trig2"
        significance="normal">
        <primary>déclencheurs de build</primary>
        <secondary>paramétrés</secondary>
      </indexterm>vous déclenchez une autre tâche de build depuis une tâche de
    build paramétrée, il est souvent utile de pouvoir passer les paramètres du
    build courant au nouveau. Supposons, par exemple, que vous ayez une
    application qui doit être testée sur plusieurs bases de données
    différentes. Comme nous l'avons vu, vous pourriez faire cela en
    configurant une tâche de build paramétré qui accepte la base de données
    cible comme un paramètre. Vous sélectionneriez une série de builds, et tous
    auraient besoin de ce paramètre.</para>
    <para>Si vous essayez de faire cela en utiliser l'option conventionnelle
    "Construire d'autres projets" dans la section Actions Post-Build, cela ne
    marchera pas. En effet, vous ne pouvez pas déclencher un build paramétré
    de cette façon.</para>
    <para>Toutefois, <indexterm id="I_indexterm10_d1e14434"
        significance="normal">
        <primary>plugins</primary>
        <secondary>Parameterized Trigger</secondary>
      </indexterm><indexterm id="I_indexterm10_d1e14439" significance="normal">
        <primary>le plugin Parameterized Trigger</primary>
      </indexterm>vous pouvez le faire en utilisent le plugin Jenkins
    Parameterized Trigger. Ce plugin vous permet de configurer vos tâches de
    build à la fois pour déclencher des builds paramétrés et pour passer des
    paramètres arbitraires à ces builds.</para>
    <para>Une fois que vous avez installé ce plugin, vous trouverez l'option
    “Déclencher des builds paramétrés sur d'autres projets” dans la page de
    configuration de votre tâche de build (voir <xref
    linkend="fig-hudson-build-parameters-trigger" />). Ceci vous permet de
    démarrer une autre tâche de build de différentes façons. En particulier,
    vous pouvez lancer une tâche de build ultérieure, en passant les
    paramètres courant à cette nouvelle tâche, ce qui est impossible à faire
    avec un builld paramétré normal. La meilleure façon de voir comment cela
    fonctionne est au travers d'un exemple.</para>
    <para>Dans <xref linkend="fig-hudson-build-parameters-unit-test" /> nous
    avons une tâche de build initiale. Cette tâche prend un unique paramètre,
    <literal moreinfo="none">DATABASE</literal>, qui spécifie la base de
    données à utiliser pour les tests. Comme nous l'avons vu, Jenkins
    demandera à l'utilisateur de saisir cette valeur à chaque fois qu'un build
    sera lancé.</para>
    <figure float="0" id="fig-hudson-build-parameters-unit-test">
      <title>Tâche de build paramétré pour des tests unitaires</title>
      <mediaobject id="I_mediaobject10_d1e14457">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_1015.pdf" format="PDF" />
        </imageobject>
        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_1015.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>
    <para>Supposons maintenant que nous voulons déclencher une seconde tâche
    de build pour exécuter des tests d'intégration plus complets une fois que
    la première tâche a terminé. Cependant nous avons besoin d'exécuter les
    tests sur la même base de données. On peut faire cela en configurant un
    déclencheur paramétré pour démarrer cette seconde tâche (voir <xref
    linkend="fig-hudson-build-parameters-trigger" />).</para>
    <figure float="0" id="fig-hudson-build-parameters-trigger">
      <title>Ajouter un déclencheur paramétré à une tâche de build</title>
      <mediaobject id="I_mediaobject10_d1e14469">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_1016.pdf" format="PDF" />
        </imageobject>
        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_1016.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>
    <para>Dans ce cas, nous passons simplement les paramètres du build
    courant. Cette seconde tâche de build démarrera automatiquement après la
    première, avec la valeur du paramètre <literal
    moreinfo="none">DATABASE</literal> fournie par l'utilisateur. Vous pouvez
    aussi configurer finement la politique de déclenchement en indiquant à
    Jenkins quand le build doit être lancé. Typiquement, vous déclencheriez
    seulement un build aval après que votre build ait réussi, mais avec le
    plugin Parameterized Trigger vous pouvez aussi configurer les builds pour
    qu'ils déclenchent même si le build est instable, ou seulement quand le build
    échoue ou encore demander à ce qu'il soit déclenché quoi qu'il arrive au premier
    build. Vous pouvez même configurer plusieurs déclencheurs pour la même
    tâche de build.</para>
    <para>Naturellement, la tâche de build que vous déclenchez doit être une
    tâche de build paramétré (comme illustré dans <xref
    linkend="fig-hudson-build-parameters-integration-test" />), et vous devez
    transmettre tous les paramètres qu'elle requiert.</para>
    <figure float="0" id="fig-hudson-build-parameters-integration-test">
      <title>La tâche de build que vous déclenchez doit aussi être une tâche
      paramétrée</title>
      <mediaobject id="I_mediaobject10_d1e14487">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_1017.pdf" format="PDF" />
        </imageobject>
        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_1017.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>
    <para>Cette fonctionnalité possède en fait des applications bien plus
    larges que de simplement transmettre les paramètres du build courant. Vous
    pouvez aussi déclencher une tâche de build paramétré avec un ensemble
    arbitraire de paramètres, ou utiliser une combinaison de paramètres passés
    au build courant, et vos propres paramètres traditionnels. Ou alors, si
    vous avez beaucoup de paramètres, vous pouvez les charger à partir d'un
    fichier de propriétés. Dans <xref
    linkend="fig-hudson-build-parameters-deploy-trigger" />, nous passons à la
    fois les paramètres du build courant (la variable <literal
    moreinfo="none">DATABASE</literal> dans ce cas), et un paramètre
    additionnel <indexterm class="endofrange" id="I_indexterm10_d1e14499"
        significance="normal" startref="ch10-trig1">
        <primary></primary>
      </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14501"
        significance="normal" startref="ch10-trig2">
        <primary></primary>
      </indexterm>appelé <literal
    moreinfo="none">TARGET_PLATFORM</literal>.</para>
    <figure float="0" id="fig-hudson-build-parameters-deploy-trigger">
      <title>Passer un paramètre prédéfini à une tâche de build
      paramétré</title>
      <mediaobject id="I_mediaobject10_d1e14510">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_1018.pdf" format="PDF" />
        </imageobject>
        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_1018.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>
  </sect1>
  <sect1 id="sect-multi-configuration-build-jobs">
    <title>Tâches de build multiconfiguration</title>
    <para>Les tâches de build <indexterm class="startofrange" id="ch10-multi1"
        significance="normal">
        <primary>tâches de build</primary>
        <secondary>multiconfiguration</secondary>
      </indexterm><indexterm class="startofrange" id="ch10-multi2"
        significance="normal">
        <primary>tâche de build multiconfiguration</primary>
      </indexterm><indexterm id="I_indexterm10_d1e14528" significance="normal">
        <primary>tâches de build paramétré</primary>
        <seealso>tâches de build multiconfiguration</seealso>
      </indexterm>multiconfiguration sont une fonctionnalité extrêmement
    puissante de Jenkins. Une tâche de build multiconfiguration peut être vue
    comme une tâche de build paramétré qui peut être automatiquement
    lancée avec toutes les combinaisons possibles de paramètres qu'elle puisse
    accepter. Elles sont particulièrement utiles pour les tests, vous
    permettant ainsi de tester votre application avec une seule tâche de
    build, mais avec une grande variété de conditions (navigateurs, bases de
    données, et ainsi de suite).</para>
    <sect2>
      <title>Configurer un build multiconfiguration</title>
      <para>Pour <indexterm class="startofrange" id="ch10-mcreate1"
          significance="normal">
          <primary>tâches de build multiconfiguration</primary>
          <secondary>créer</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-mcreate2"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>multiconfiguration</secondary>
          <tertiary>créer</tertiary>
        </indexterm>créer une nouvelle tâche de build multiconfiguration,
      choisissez simplement l'option suivante sur la page Nouvelle Tâche (voir
      <xref linkend="fig-hudson-build-multi-configuration" />).</para>
      <figure float="0" id="fig-hudson-build-multi-configuration">
        <title>Créer une tâche de build multiconfiguration</title>
        <mediaobject id="I_mediaobject10_d1e14557">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1019.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1019.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Une tâche de build multiconfiguration ressemble à n'importe quelle
      autre tâche, mais avec un élément supplémentaire très important : la
      <firstterm>Matrice de Configuration</firstterm> (voir <xref
      linkend="fig-hudson-build-multi-config" />). C'est là que vous
      définissez les différentes configurations qui seront utilisées pour
      exécuter vos builds.</para>
      <figure float="none" id="fig-hudson-build-multi-config">
        <title>Ajouter un axe à un build multiconfiguration</title>
        <mediaobject id="I_mediaobject10_d1e14572">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1020.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1020.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Vous pouvez définir différents axes d'options de configuration,
      incluant l'exécution de la tâche de build sur différents esclaves ou sur
      différents JDKs, ou en fournissant vos propres propriétés personnalisées
      au build. Par exemple, dans les tâches de build discutées précédemmennt,
      nous pourrions vouloir tester notre application pour différentes bases
      de données et différents systèmes d'exploitation. Nous pourrions définir
      un axe définissant les machines esclaves avec différents systèmes
      d'exploitation sur lesquels nous voudrions faire tourner nos builds, et
      un autre axe définissant toutes les valeurs possibles de bases de
      données. Jenkins exécutera ensuite la tâche de build pour chaque base de
      données et chaque système d'exploitation possibles.</para>
      <para>Regardons à présent les types d'axes que nous pouvons<indexterm
          class="endofrange" id="I_indexterm10_d1e14581" significance="normal"
          startref="ch10-mcreate1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14583"
          significance="normal" startref="ch10-mcreate2">
          <primary></primary>
        </indexterm> définir.</para>
    </sect2>
    <sect2>
      <title>Configurer un axe Esclave</title>
      <para>La<indexterm class="startofrange" id="ch10-slave1"
          significance="normal">
          <primary>tâches de build multiconfiguration</primary>
          <secondary>axe esclave pour</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-slave2"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>multiconfiguration</secondary>
          <tertiary>axe esclave pour</tertiary>
        </indexterm><indexterm class="startofrange" id="ch10-slave3"
          significance="normal">
          <primary>machines esclaves</primary>
          <secondary sortas="multi-config">pour tâches de build
          multiconfiguration</secondary>
        </indexterm> première option consiste à configurer votre build pour
      exécuter simultanément le build sur différentes machines esclaves (voir
      <xref linkend="chapter-distributed-builds" />). Evidemment, l'idée
      d'avoir un ensemble de machines esclaves est généralement pour que
      vous puissiez exécuter votre build sur n'importe laquelle. Mais il y a
      des cas où il est normal d'être plus sélectif. Par exemple, vous
      pourriez vouloir lancer vos tests sur Windows, Mac OS X, et Linux. Dans
      ce cas, vous créez un nouvel axe pour vos noeuds esclaves, comme montré
      dans <xref linkend="fig-build-multi-config-slaves" />. Vous pouvez
      choisir les noeuds que vous voulez utiliser de deux façons : par label
      ou par noeud individuel. Utiliser des labels vous permet d'identifier
      des catégories de noeuds de construction (par exemple, des machines
      Windows), sans lier le build à aucune machine en particulier. C'est une
      option plus flexible, et elle rend plus facile l'extension de votre
      capacité de build si nécessaire. Parfois, cependant, vous pouvez
      réellement vouloir exécuter un build sur une machine spécifique. Dans ce
      cas, vous pouvez utiliser l'option "Noeuds individuels" et choisir la
      machine dans la liste.</para>
      <figure float="none" id="fig-build-multi-config-slaves">
        <title>Définir un axe de noeuds esclave</title>
        <mediaobject id="I_mediaobject10_d1e14616">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1021.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1021.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Si vous avez besoin de plus de flexibilité, vous pouvez aussi
      utiliser une Label Expression, ce qui vous permet de définir quels
      noeuds esclaves peuvent être utilisés pour un axe particulier en
      utilisant des expressions booléennes et des opérateurs logiques pour
      combiner les labels. Par exemple, supposons que vous avez défini des
      labels pour les machines esclaves en fonction du système d'exploitation
      (“windows”, “linux”) et des bases de données installées (“oracle”,
      “mysql”, “db2”). Pour définir un axe n'exécutant les tests que pour les
      machines Windows sur lesquelles est installé MySQL, vous pouvez utiliser
      une expression comme <literal moreinfo="none">windows &amp;&amp;
      mysql</literal>.</para>
      <para>Nous traitons du travail avec des noeuds esclaves et les builds
      distribués plus en <indexterm class="endofrange"
          id="I_indexterm10_d1e14628" significance="normal"
          startref="ch10-slave1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14630"
          significance="normal" startref="ch10-slave2">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14632"
          significance="normal" startref="ch10-slave3">
          <primary></primary>
        </indexterm>détail dans <phrase role="keep-together"><xref
      linkend="chapter-distributed-builds" /></phrase>.</para>
    </sect2>
    <sect2>
      <title>Configurer un axe JDK</title>
      <para>Si vous<indexterm id="I_indexterm10_d1e14643"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>axe JDK pour</secondary>
        </indexterm><indexterm id="I_indexterm10_d1e14648"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>multiconfiguration</secondary>
          <tertiary>axe JDK pour</tertiary>
        </indexterm><indexterm id="I_indexterm10_d1e14655"
          significance="normal">
          <primary>JDK (Java Development Kit)</primary>
          <secondary>versions du, pour tâches de build
          multiconfiguration</secondary>
        </indexterm> déployez votre application sur une large base client sur
      laquelle vous avez un contrôle limité de l'environnement cible, vous
      pouvez avoir besoin de tester votre application en testant différentes
      versions de Java. Dans ce genre de cas, il est utile de pouvoir mettre
      en place un axe JDK dans un build multiconfiguration. Quand vous ajoutez
      un axe JDK, Jenkins propose automatiquement la liste des versions de JDK
      dont il a connaissance (voir <xref
      linkend="fig-hudson-build-multi-config-jdk" />). Si vous avez besoin
      d'utiliser des JDKs additionnels, ajoutez les simplement à votre page de
      configuration Jenkins.</para>
      <figure float="0" id="fig-hudson-build-multi-config-jdk">
        <title>Définir un axe de versions de JDK</title>
        <mediaobject id="I_mediaobject10_d1e14666">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1022.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1022.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
    <sect2>
      <title>Axe personnalisé</title>
      <para>Le<indexterm id="I_indexterm10_d1e14676" significance="normal">
          <primary>tâches de build multiconfiguration</primary>
          <secondary>axe personnalisé</secondary>
        </indexterm><indexterm id="I_indexterm10_d1e14681"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>multiconfiguration</secondary>
          <tertiary>axe personnalisé pour</tertiary>
        </indexterm> troisième type d'axe vous permet de définir différentes
      façons d'exécuter votre tâche de build, basées sur des variables
      arbitraires que vous définissez. Par exemple, vous pouvez fournir une
      liste de bases de données que vous avez besoin de tester, ou une liste
      de navigateurs à utiliser dans vos tests web. Ceci est très similaire
      aux paramètres pour une tâche de build paramétré, excepté que vous
      fournissez la liste complète des valeurs possibles, et que plutôt que
      d'interroger l'utilisateur pour qu'il entre une valeur, Jenkins lance le
      build avec <emphasis>toutes</emphasis> les valeurs fournies (<xref
      linkend="fig-hudson-build-mulit-config-custom" />).</para>
      <figure float="none" id="fig-hudson-build-mulit-config-custom">
        <title>Définir un axe spécifique à l'utilisateur</title>
        <mediaobject id="I_mediaobject10_d1e14697">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1023.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1023.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
    <sect2>
      <title>Exécuter un Build Multiconfiguration</title>
      <para>Une fois que<indexterm class="startofrange" id="ch10-mrun1"
          significance="normal">
          <primary>tâches de build multiconfiguration</primary>
          <secondary>exécuter</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-mrun2"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>multiconfiguration</secondary>
          <tertiary>exécuter</tertiary>
        </indexterm> vous avez configuré les axes, vous pouvez exécuter votre
      build multiconfiguration comme n'importe quel autre. Toutefois, Jenkins
      traitera chaque combinaison de variables comme un build séparé. Jenkins
      affiche les résultats agrégés dans un tableau, où toutes les
      combinaisons sont montrées (voir <xref
      linkend="fig-hudson-build-multi-config-results" />). Si vous cliquez sur
      les boules, Jenkins vous emmènera aux résultats détaillés pour un build
      particulier.</para>
      <figure float="0" id="fig-hudson-build-multi-config-results">
        <title>Résultats de build multiconfiguration</title>
        <mediaobject id="I_mediaobject10_d1e14725">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1024.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1024.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Par défaut, Jenkins exécutera les tâches de build en parallèle.
      Toutefois, il y a quelques cas où cela n'est pas une bonne idée. Par
      exemple, de nombreuses applications web Java utilisent des tests
      Selenium ou WebDriver s'exécutant sur une instance locale de Jetty
      automatiquement démarrée par la tâche. Les scripts de build de ce genre
      doivent être spécialement configurés pour pouvoir s'exécuter en
      parallèle sur la même machine, pour éviter les conflits de ports.
      L'accès concurrent à la base de données pendant les tests peut être une
      autre source de problèmes si la gestion de la concurrence n'est pas
      intégrée à la conception des tests. Si vos builds ne sont pas conçus
      pour fonctionner en parallèle, vous pouvez forcer Jenkins à exécuter les
      tests de manière séquentielle en cochant la case Exécuter chaque
      configuration séquentiellement en bas <indexterm
          id="I_indexterm10_d1e14732" significance="normal">
          <primary>tâches de build multiconfiguration</primary>
          <secondary>matrice de configuration</secondary>
        </indexterm><indexterm id="I_indexterm10_d1e14737"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>multiconfiguration</secondary>
          <tertiary>matrice de configuration</tertiary>
        </indexterm> de la section Configuration de la matrice.</para>
      <para>Par défaut, Jenkins exécutera toutes les combinaisons possibles
      des différents axes. Donc, dans l'exemple ci-dessus, nous avons trois
      environnements, deux JDKs et quatre bases de données. Ceci résulte en un
      total de 24 builds. Toutefois, dans certains cas, exécuter certaines
      combinaisons ne pourrait avoir aucun sens (ou n'être pas possible). Par
      exemple, supposons que vous ayez une tâche de build qui exécute des
      tests web automatisés. Si un axe contient les navigateurs web à tester
      (Firefox, Internet Explorer, Chrome, etc.) et un autre les systèmes
      d'exploitation (Linux, Windows, Mac OS), cela n'aurait pas beaucoup de
      sens d'exécuter Internet Explorer avec Linux ou Mac OS.</para>
      <para>L'<indexterm id="I_indexterm10_d1e14749" significance="normal">
          <primary>tâches de build</primary>
          <secondary>multiconfiguration</secondary>
          <tertiary>filtre de combinaison pour</tertiary>
        </indexterm><indexterm id="I_indexterm10_d1e14756"
          significance="normal">
          <primary>tâches de build multiconfiguration</primary>
          <secondary>filtre de combinaison pour</secondary>
        </indexterm>option de Filtre de Combinaison vous permet de mettre en
      place des règles définissant quelles combinaisons de variables sont
      valides. Ce champ est une expression booléene Groovy qui utilise les
      noms des variables que vous définissez pour chaque axe. L'expression
      doit valoir true pour que le build s'exécute. Par exemple, supposez que
      vous ayez une tâche de build exécutant des tests web dans différents
      navigateurs sur différents systèmes d'exploitation (voir <xref
      linkend="fig-hudson-build-multi-config-filters" />). Les tests
      nécessitent d'exécuter Firefox, Internet Explorer et Chrome, sur
      Windows, Mac OS X, et Linux. Toutefois Internet Explorer ne fonctionne
      que sous Windows, et Chrome ne fonctionne pas sous Linux.</para>
      <figure float="none" id="fig-hudson-build-multi-config-filters">
        <title>Mettre en place un filtre de combinaison</title>
        <mediaobject id="I_mediaobject10_d1e14767">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1025.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1025.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Pour configurer un Filtre de Combinaison, nous pourrions utiliser
      une expression comme la suivante :</para>
      <programlisting format="linespecific" id="I_programlisting10_d1e14774">(browser=="firefox")
|| (browser=="iexplorer" &amp;&amp; os=="windows")
|| (browser=="chrome" &amp;&amp; os != "linux")</programlisting>
      <para>Ceci résulterait dans le fait que seules les combinaisons
      correctes navigateur/système d'exploitation seraient exécutées (voir
      <xref linkend="fig-hudson-multi-config-filter-result" />). Les builds
      exécutés sont affichés dans les couleurs habituelles, alors que les
      builds non-exécutés sont grisés.</para>
      <figure float="0" id="fig-hudson-multi-config-filter-result">
        <title>Résultats de build utilisant un filtre de combinaison</title>
        <mediaobject id="I_mediaobject10_d1e14783">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1026.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1026.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Une autre raison d'utiliser un filtre de build est qu'il y a
      simplement trop de combinaisons valides pour s'exécuter dans un temps
      raisonnable. Dans ce cas, la meilleure solution pourrait être
      d'augmenter la capacité de votre serveur de build. La deuxième meilleure
      solution, d'un autre côté, serait d'exécuter uniquement un sous-ensemble
      des combinaisons, éventuellement exécutant l'ensemble complet de
      combinaison pendant la nuit. Vous pouvez faire cela en utilisant la
      variable spéciale <code>index</code>. Si vous incluez l'expression
      <code>(index%2 == 0)</code>, par exemple, cela assurera que seulement un
      build sur deux est en fait exécuté.</para>
      <para>Vous pourriez aussi vouloir que certains builds s'exécutent avant
      les autres, comme tests de cohérence. Par exemple, vous pouvez vouloir
      exécuter la configuration par défaut (et, théoriquement, la plus fiable)
      pour votre application en premier, avant de continuer avec des
      combinaisons plus exotiques. Pour faire cela, vous pouvez utiliser
      l'option “Execute touchstone builds first”. Ici, vous entrez une valeur
      de filtre (comme celle montrée ci-dessus) pour définir le ou les
      premiers builds à exécuter. Vous pouvez aussi spécifier si le build
      devrait continuer seulement si ces builds sont réussis, ou même s'ils
      échouent. Une fois que ces builds se sont terminés comme prévu, Jenkins
      procédera au lancement des autres<indexterm class="endofrange"
          id="I_indexterm10_d1e14799" significance="normal"
          startref="ch10-mrun1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14801"
          significance="normal" startref="ch10-mrun2">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14803"
          significance="normal" startref="ch10-multi1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e14805"
          significance="normal" startref="ch10-multi2">
          <primary></primary>
        </indexterm> combinaisons.</para>
    </sect2>
  </sect1>
  <sect1 id="I_sect110_d1e14808">
    <title>Générer vos tâches de build Maven automatiquement</title>
    <para><emphasis>Rédigé par Evgeny Goldin</emphasis></para>
    <para>Comme <indexterm class="startofrange" id="ch10-mavengen"
        significance="normal">
        <primary>tâches de build Maven</primary>
        <secondary>générer automatiquement</secondary>
      </indexterm>mentionné dans la section précédente, le nombre de tâches de
    build que votre serveur Jenkins héberge peut varier. Lorsque ce nombre
    grossira, il deviendra plus difficile non seulement de les voir dans le
    tableau de bord Jenkins, mais aussi de les configurer. Imaginez ce que
    nécessiterait la configuration de 20 à 50 tâches une par une ! De plus,
    plusieurs de ces tâches pourraient avoir en commun des éléments de
    configuration, comme des goals Maven ou des paramètres de configuration
    mémoire, ce qui résulte en une configuration dupliquée et un surplus de
    maintenance.</para>
    <para>Par exemple, si vous décidez d'exécuter <literal moreinfo="none">mvn
    clean install</literal> au lieu de <literal moreinfo="none">mvn clean
    deploy</literal> pour vos tâches de release et de passer à des méthodes de
    déploiement alternatives, comme celles fournies par le plugin<ulink
    url="http://wiki.jenkins-ci.org/display/JENKINS/Artifactory+Plugin">Artifactory
    </ulink>, vous n'aurez plus d'autre choix que d'ouvrir toutes les
    tâches concernées et de les mettre à jour manuellement.</para>
    <para>Sinon, vous pourriez tirer parti du fait que Jenkins est un outil
    simple et direct qui garde trace de toutes ses définitions sur le disque 
    dans des fichiers bruts. En effet, vous pouvez mettre à jour les
    fichiers <filename moreinfo="none">config.xml</filename> de vos tâches
    directement dans le répertoire <filename
    moreinfo="none">.jenkins/jobs</filename> où ils sont conservés. Bien que
    cette approche fonctionnerait, elle est loin d'être idéale parce qu'elle
    implique un nombre assez important de sélections manuelles et de
    remplacements délicats dans des fichiers XML Jenkins.</para>
    <para>Il y a une troisième façon d'atteindre le nirvana des mises à jour
    massives de tâches : générer vos fichiers de configuration automatiquement
    en utilisant une sorte de fichier de définition. Le <indexterm
        id="I_indexterm10_d1e14843" significance="normal">
        <primary>Maven Jenkins plugin</primary>
      </indexterm><indexterm id="I_indexterm10_d1e14846" significance="normal">
        <primary>plugins</primary>
        <secondary>Maven Jenkins</secondary>
      </indexterm> <ulink
    url="http://evgeny-goldin.com/wiki/Maven-jenkins-plugin">Maven Jenkins
    Plugin</ulink> fait exactement cela : générer les fichiers <filename
    moreinfo="none">config.xml</filename> pour toutes les tâches en utilisant
    des définitions standards conservées dans un unique fichier <filename
    moreinfo="none">pom.xml</filename>.</para>
    <sect2>
      <title>Configurer une tâche</title>
      <para>Quand <indexterm class="startofrange" id="ch10-mavenconfig"
          significance="normal">
          <primary>tâches de build Maven</primary>
          <secondary>générer automatiquement</secondary>
          <tertiary>configurer</tertiary>
        </indexterm>vous configurez une tâche avec le Maven Jenkins Plugin,
      vous pouvez définir tous les éléments habituels de configuration, comme
      les goals Maven, l'emplacement du POM, les URL de dépôts, les adresses
      e-mail, le nombre de jours pendant lesquels conserver les logs, et ainsi
      de suite. Le plugin essaie de vous rapprocher au plus près de la
      configuration classique d'une tâche dans Jenkins.</para>
      <para>Jetons un oeil à la tâche de build de <ulink
      url="http://code.google.com/p/google-guice/">Google Guice</ulink>
      :</para>
      <screen format="linespecific">&lt;job&gt;
    &lt;id&gt;google-guice-trunk&lt;/id&gt;
    &lt;description&gt;Building Google Guice trunk.&lt;/description&gt;
    &lt;descriptionTable&gt;
        &lt;row&gt;
            &lt;key&gt;Project Page&lt;/key&gt;
            &lt;value&gt;
                &lt;a href="http://code.google.com/p/google-guice/"&gt;
                    &lt;b&gt;&lt;code&gt;code.google.com/p/google-guice&lt;/code&gt;&lt;/b&gt;
                &lt;/a&gt;
            &lt;/value&gt;
            &lt;escapeHTML&gt;false&lt;/escapeHTML&gt;
            &lt;bottom&gt;false&lt;/bottom&gt;
        &lt;/row&gt;
    &lt;/descriptionTable&gt;
    &lt;jdkName&gt;jdk1.6.0&lt;/jdkName&gt;
    &lt;mavenName&gt;apache-maven-3&lt;/mavenName&gt;
    &lt;mavenOpts&gt;-Xmx256m -XX:MaxPermSize=128m&lt;/mavenOpts&gt;
    &lt;daysToKeep&gt;5&lt;/daysToKeep&gt;
    &lt;useUpdate&gt;false&lt;/useUpdate&gt;
    &lt;mavenGoals&gt;-e clean install&lt;/mavenGoals&gt;
    &lt;trigger&gt;
        &lt;type&gt;timer&lt;/type&gt;
        &lt;expression&gt;0 0 * * *&lt;/expression&gt;
    &lt;/trigger&gt;
    &lt;repository&gt;
        &lt;remote&gt;http://google-guice.googlecode.com/svn/trunk/&lt;/remote&gt;
    &lt;/repository&gt;
    &lt;mail&gt;
        &lt;recipients&gt;jenkins@evgeny-goldin.org&lt;/recipients&gt;
    &lt;/mail&gt;
&lt;/job&gt;</screen>
      <para>Cette tâche utilise un certain nombre de configurations standards
      comme <literal moreinfo="none">&lt;jdkName&gt;</literal>, <literal
      moreinfo="none">&lt;mavenName&gt;</literal> et <literal
      moreinfo="none">&lt;mavenOpts&gt;</literal>. Le code est récupéré à
      partir d'un dépôt Subversion (défini dans l'élément <literal
      moreinfo="none">&lt;repository&gt;</literal>), et un <literal
      moreinfo="none">&lt;trigger&gt;</literal> cron qui exécute la tâche
      pendant la nuit à 00:00. Les notifications Email sont envoyées aux
      personnes spécifiées avec l'élément <literal
      moreinfo="none">&lt;mail&gt;</literal>. Cette configuration ajoute aussi
      un lien vers la page du projet dans le tableau de description généré
      automatiquement pour chaque tâche.</para>
      <para>Cette tâche générée est affichée dans votre serveur Jenkins comme
      illustré dans <xref
      linkend="jenkins-plugin-google-guice-trunk-job" />.</para>
      <figure float="none" id="jenkins-plugin-google-guice-trunk-job">
        <title>Une tâche générée avec le Maven Jenkins plugin</title>
        <mediaobject id="I_mediaobject10_d1e14909">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1027.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1027.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Voici une autre tâche réalisant la build de la branche master du projet 
	  Jenkins hébergé chez GitHub
      :</para>
      <screen format="linespecific">&lt;job&gt;
    &lt;id&gt;jenkins-master&lt;/id&gt;
    &lt;jdkName&gt;jdk1.6.0&lt;/jdkName&gt;
    &lt;numToKeep&gt;5&lt;/numToKeep&gt;
    &lt;mavenName&gt;apache-maven-3&lt;/mavenName&gt;
    &lt;trigger&gt;
        &lt;type&gt;timer&lt;/type&gt;
        &lt;expression&gt;0 1 * * *&lt;/expression&gt;
    &lt;/trigger&gt;
    &lt;scmType&gt;git&lt;/scmType&gt;
    &lt;repository&gt;
        &lt;remote&gt;git://github.com/jenkinsci/jenkins.git&lt;/remote&gt;
    &lt;/repository&gt;
    &lt;mail&gt;
        &lt;recipients&gt;jenkins@evgeny-goldin.org&lt;/recipients&gt;
        &lt;sendForUnstable&gt;false&lt;/sendForUnstable&gt;
    &lt;/mail&gt;
&lt;/job&gt;</screen>
      <para>Elle génère la tâche montrée dans <xref
      linkend="jenkins-plugin-jenkins-master-job" />.</para>
      <figure float="0" id="jenkins-plugin-jenkins-master-job">
        <title>Tâche générée jenkins-master</title>
        <mediaobject id="I_mediaobject10_d1e14925">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1028.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1028.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>La <ulink
      url="http://evgeny-goldin.com/wiki/Maven-jenkins-plugin#.3Cjob.3E">documentation</ulink>
      du plugin fournit une référence détaille de tous les paramètres qui
      peuvent être <indexterm class="endofrange" id="I_indexterm10_d1e14936"
          significance="normal" startref="ch10-mavenconfig">
          <primary></primary>
        </indexterm>configurés.</para>
    </sect2>
    <sect2>
      <title>Réutiliser une configuration de tâche par héritage</title>
      <para>Être <indexterm class="startofrange" id="ch10-inherit"
          significance="normal">
          <primary>Tâches de build Maven</primary>
          <secondary>générer automatiquement</secondary>
          <tertiary>héritage de configuration</tertiary>
        </indexterm> capable de générer des tâches Jenkins jobs en utilisant
      une configuration centralisée, comme un POM Maven, résout le problème de
      la création et de la mise à jour de plusieurs tâches à la fois. Tout ce
      que vous avez à faire est de modifier les définitions de job, relancer
      le plugin et charger les définitions mises à jour avec Administrer Jenkins<phrase
      role="unicode">→</phrase>“Recharger la configuration à
      partir du disque”. Cette approche a aussi l'avantage de rendre facile le
      stockage de vos configurations de tâche dans un système de gestion de
      versions, ce qui rend par la même plus facile le suivi des changements
      faits aux configurations de build.</para>
      <para>Cela ne résout toutefois pas le problème consistant à maintenir
      des tâches qui partagent un certain nombre de propriétés identiques,
      comme les goals Maven, les destinataires email ou l'URL du dépôt de
      code. Pour cela, le Maven Jenkins Plugin fournit de l'héritage de
      tâches, démontré dans l'exemple suivant<phrase
      role="keep-together"></phrase>:</para>
      <screen format="linespecific">&lt;jobs&gt;
    &lt;job&gt;
        &lt;id&gt;google-guice-inheritance-base&lt;/id&gt;
        &lt;abstract&gt;true&lt;/abstract&gt;
        &lt;jdkName&gt;jdk1.6.0&lt;/jdkName&gt;
        &lt;mavenName&gt;apache-maven-3&lt;/mavenName&gt;
        &lt;daysToKeep&gt;5&lt;/daysToKeep&gt;
        &lt;useUpdate&gt;true&lt;/useUpdate&gt;
        &lt;mavenGoals&gt;-B -e -U clean install&lt;/mavenGoals&gt;
        &lt;mail&gt;&lt;recipients&gt;jenkins@evgeny-goldin.org&lt;/recipients&gt;&lt;/mail&gt;
    &lt;/job&gt;
 
    &lt;job&gt;
        &lt;id&gt;google-guice-inheritance-trunk&lt;/id&gt;
        &lt;parent&gt;google-guice-inheritance-base&lt;/parent&gt;
        &lt;repository&gt;
            &lt;remote&gt;http://google-guice.googlecode.com/svn/trunk/&lt;/remote&gt;
        &lt;/repository&gt;
    &lt;/job&gt;
 
    &lt;job&gt;
        &lt;id&gt;google-guice-inheritance-3.0-rc3&lt;/id&gt;
        &lt;parent&gt;google-guice-inheritance-base&lt;/parent&gt;
        &lt;repository&gt;
            &lt;remote&gt;http://google-guice.googlecode.com/svn/tags/3.0-rc3/&lt;/remote&gt;
        &lt;/repository&gt;
    &lt;/job&gt;
 
    &lt;job&gt;
        &lt;id&gt;google-guice-inheritance-2.0-maven&lt;/id&gt;
        &lt;parent&gt;google-guice-inheritance-base&lt;/parent&gt;
        &lt;mavenName&gt;apache-maven-2&lt;/mavenName&gt;
        &lt;repository&gt;
            &lt;remote&gt;http://google-guice.googlecode.com/svn/branches/2.0-maven/
            &lt;/remote&gt;
        &lt;/repository&gt;
    &lt;/job&gt;
&lt;/jobs&gt;</screen>
      <para>Dans cette configuration,
      <emphasis>google-guice-inheritance-base</emphasis> est une tâche parent
      abstraite contenant toutes les propriétés communes : le nom du JDK, le
      nom de Maven, le nombre de jours de conservation des logs, la politique
      de mise à jour SVN, les goals Maven et les destinataires email. Les
      trois tâches suivantes sont très courtes, spécifiant simplement qu'elles
      étendent une tâche <literal moreinfo="none">&lt;parent&gt;</literal> et
      ajoutent les configurations manquantes (URLs de dépôt dans ce
      cas)<phrase role="keep-together">. Une fois générées, elles héritent de
      toutes les propriétés de la tâche parente
      automatiquement</phrase>.</para>
      <para>Toute propriété héritée peut être rédéfinie, comme démontré dans
      la tâche <emphasis>google-guice-<phrase
      role="keep-together">inheritance-</phrase>2.0-maven</emphasis> où Maven
      2 est utilisé à la place de Maven 3. Si vous voulez "annuler" une
      propriété hériétée, vous devrez la redéfinir avec une valeur
      vide.</para>
      <para>L'héritage de tâches est un concept très puissant qui permet aux
      tâches de former des groupes hiérarchiques de n'importe quel type et
      dans n'importe quel but. Vous pouvez grouper vos tâches d'IC, noctures
      ou de release de cette façon, en centralisant les déclencheurs
      d'exécution partagés, les goals Maven ou les destinataires email dans
      des tâches parentes. Cette approche emprunté au monde orienté object
      permet de résoudre le problème de maintenance de tâches partageant un
      certain nombre de propriétés <indexterm class="endofrange"
          id="I_indexterm10_d1e14986" significance="normal"
          startref="ch10-inherit">
          <primary></primary>
        </indexterm>identiques.</para>
    </sect2>
    <sect2>
      <title>Le support des plugins</title>
      <para>En plus de configurer une tâche et de réutiliser ses définitions,
      vous pouvez bénéficier d'un support spécial pour un certain nombre
      de plugins Jenkins. À l'heure actuelle, une utilisation simplifiée des
      plugins Parameterized Trigger et Artifactory est fournie, un
      support pour d'autres plugins populaires est prévu dans de futures
      versions.</para>
      <para>Ci-dessous<indexterm id="I_indexterm10_d1e14996"
          significance="normal">
          <primary>plugin Parameterized Trigger</primary>
        </indexterm><indexterm id="I_indexterm10_d1e14999"
          significance="normal">
          <primary>plugins</primary>
          <secondary>Parameterized Trigger</secondary>
        </indexterm><indexterm id="I_indexterm10_d1e15004"
          significance="normal">
          <primary>Tâches de build Maven</primary>
          <secondary>générer automatiquement</secondary>
          <tertiary>plugin Parameterized Trigger avec</tertiary>
        </indexterm> se trouve un exemple d'invocation de tâches avec le
      plugin Parameterized Trigger. Utiliser cette option suppose que vous
      avez déjà ce plugin installé :</para>
      <screen format="linespecific">&lt;job&gt;
    &lt;id&gt;google-guice-inheritance-trunk&lt;/id&gt;
    ...
    &lt;invoke&gt;
        &lt;jobs&gt;
            google-guice-inheritance-3.0-rc3,
            google-guice-inheritance-2.0-maven
        &lt;/jobs&gt;
    &lt;/invoke&gt;
&lt;/job&gt;
 
&lt;job&gt;
    &lt;id&gt;google-guice-inheritance-3.0-rc3&lt;/id&gt;
    ...
&lt;/job&gt;
 
&lt;job&gt;
    &lt;id&gt;google-guice-inheritance-2.0-maven&lt;/id&gt;
    ...
&lt;/job&gt;</screen>
      <para>L'élément <literal moreinfo="none">&lt;invoke&gt;</literal> vous
      permet d'invoquer d'autres tâches chaque fois que la tâche courante se
      termine correctement. Vous pouvez créer un pipeline de tâches de cette
      façon, vous assurant que chaque tâche du pipeline invoque la suivante.
      Notez que s'il y a plus d'un exécuteur Jenkins disponible au moment de
      l'invocation, les tâches spécifiées démarreront en parallèle. Pour une
      exécution en série, vous devrez connecter chaque tâche amont à une tâche
      aval avec <literal moreinfo="none">&lt;invoke&gt;</literal>.</para>
      <para>Par défaut, l'invocation ne se fait que quand la tâche courante est
      stable. Ceci peut être modifié, comme montré dans les exemples suivants
      :</para>
      <screen format="linespecific">&lt;invoke&gt;
    &lt;jobs&gt;jobA, jobB, jobC&lt;/jobs&gt;
    &lt;always&gt;true&lt;/always&gt;
&lt;/invoke&gt;
 
&lt;invoke&gt;
    &lt;jobs&gt;jobA, jobB, jobC&lt;/jobs&gt;
    &lt;unstable&gt;true&lt;/unstable&gt;
&lt;/invoke&gt;
 
&lt;invoke&gt;
    &lt;jobs&gt;jobA, jobB, jobC&lt;/jobs&gt;
    &lt;stable&gt;false&lt;/stable&gt;
    &lt;unstable&gt;false&lt;/unstable&gt;
    &lt;failed&gt;true&lt;/failed&gt;
&lt;/invoke&gt;</screen>
      <para>La première invocation dans l'exemple ci-dessus invoque toujours
      les tâches avals. Ceci peut être utilisé pour un pipeline de tâches qui
      devraient toujours être exécutées même si certaines, ou leurs tests,
      échouent.</para>
      <para>La seconde invocation dans l'exemple ci-dessus invoque les tâches
      avals même si une tâche amont est instable : l'invocation prend place
      quels que soient les résultats des tests. Cela peut être utilisé pour un
      pipeline de tâches moins sensibles aux tests et à leurs échecs.</para>
      <para>La troisième invocation ci-dessus invoque les tâches avals
      seulement quand une tâche amont échoue mais pas lorsqu'elle est stable ou
      instable. Cette configuration peut vous être utile si une tâche en échec
      doit effectuer des actions additionnelles autres que les notifications
      email tradtionnelles.</para>
      <para><indexterm id="I_indexterm10_d1e15033" significance="normal">
          <primary>Artifactory plugin</primary>
        </indexterm><indexterm id="I_indexterm10_d1e15036"
          significance="normal">
          <primary>plugins</primary>
          <secondary>Artifactory</secondary>
        </indexterm><indexterm id="I_indexterm10_d1e15041"
          significance="normal">
          <primary>Tâches de build Maven</primary>
          <secondary>générer automatiquement</secondary>
          <tertiary>Artifactory plugin avec</tertiary>
        </indexterm><ulink url="http://jfrog.org">Artifactory</ulink> est un
      dépôt de binaires à usage général qui peut être utilisé comme
      gestionnaire de dépôt Maven. Le <ulink
      url="http://wiki.jenkins-ci.org/display/JENKINS/Artifactory+Plugin">plugin
      Jenkins Artifactory</ulink>, montré dans <xref
      linkend="jenkins-plugin-artifactory" />, fournit un certain nombre
      d'avantages pour les tâches de build Jenkins. Nous avons déjà passé en revue
      quelques-unes d'entre elles dans <xref
      linkend="sect-builds-deploy-enterprise-repository" />, notamment la
      capacité à déployer des artefacts à l'achèvement de la tâche ou
      d'envoyer avec des informations de l'environnement de build avec les
      artefacts pour une meilleure traçabilité.</para>
      <figure float="0" id="jenkins-plugin-artifactory">
        <title>Configuration du plugin Jenkins pour Artifactory</title>
        <mediaobject id="I_mediaobject10_d1e15062">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1029.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1029.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Vous pouvez aussi utiliser le plugin Jenkins Artifactory
      conjointement au Maven Jenkins Plugin pour déployer dans Artifactory,
      comme montré dans l'exemple suivant :</para>
      <screen format="linespecific">&lt;job&gt;
    ...
    &lt;artifactory&gt;
        &lt;name&gt;http://artifactory-server/&lt;/name&gt;
        &lt;deployArtifacts&gt;true&lt;/deployArtifacts&gt;
        &lt;includeEnvVars&gt;true&lt;/includeEnvVars&gt;
        &lt;evenIfUnstable&gt;true&lt;/evenIfUnstable&gt;
    &lt;/artifactory&gt;
&lt;/job&gt;</screen>
      <para>Les informations d'identité pour le déploiement sont spécifiées
      dans la configuration de Jenkins dans l'écran Administrer Jenkins<phrase
      role="unicode">→Configurer le système</phrase>. Elles peuvent aussi être
      spécifiées pour chaque tâche Jenkins. Les dépôts Maven par défaut sont
      <filename moreinfo="none">libs-releases-local</filename> et <filename
      moreinfo="none">libs-snapshots-local</filename>. Vous trouverez plus de
      détails dans la documentation du plugin à l'adresse <ulink
      url="http://wiki.jenkins-ci.org/display/JENKINS/Artifactory+Plugin"></ulink>.</para>
    </sect2>
    <sect2>
      <title>Les tâches Freestyle</title>
      <para>En <indexterm id="I_indexterm10_d1e15089" significance="normal">
          <primary>tâches de build freestyle</primary>
          <secondary>générer automatiquement</secondary>
        </indexterm><indexterm id="I_indexterm10_d1e15094"
          significance="normal">
          <primary>Maven Jenkins plugin</primary>
        </indexterm><indexterm id="I_indexterm10_d1e15097"
          significance="normal">
          <primary>plugins</primary>
          <secondary>Maven Jenkins</secondary>
        </indexterm>supplément des tâches Maven, le Maven Jenkins Plugin vous
      permet de configurer des tâches freestyle Jenkins. Un exemple est montré
      ici :</para>
      <screen format="linespecific">&lt;job&gt;
    &lt;id&gt;free-style&lt;/id&gt;
    &lt;jobType&gt;free&lt;/jobType&gt;
    &lt;scmType&gt;git&lt;/scmType&gt;
    &lt;repository&gt;
        &lt;remote&gt;git://github.com/evgeny-goldin/maven-plugins-test.git&lt;/remote&gt;
    &lt;/repository&gt;
    &lt;tasks&gt;
        &lt;maven&gt;
            &lt;mavenName&gt;apache-maven-3&lt;/mavenName&gt;
            &lt;jvmOptions&gt;-Xmx128m -XX:MaxPermSize=128m -ea&lt;/jvmOptions&gt;
            &lt;properties&gt;plugins-version = 0.2.2&lt;/properties&gt;
        &lt;/maven&gt;
        &lt;shell&gt;&lt;command&gt;pwd; ls -al; du -hs .&lt;/command&gt;&lt;/shell&gt;
    &lt;/tasks&gt;
&lt;/job&gt;</screen>
      <para>Les tâches Freestyle vous permettent d'exécuter un shell ou une
      commande batch, exécuter Maven ou Ant, et invoquer d'autres tâches.
      Elles fournissent un environnement d'exécution bien pratique pour les
      scripts systèmes ou tout autre type d'activité qui n'est pas directement
      implémentée dans Jenkins ou l'un des ses plugins. En utilisant cette
      approche, vous pouvez générer des fichiers de configuration de tâche de
      build Freestyle de façon similaire à l'approche que nous avons vue pour
      les tâches de build Maven, ce qui peut aider à rendre votre
      environnement de construction plus cohérent <indexterm
          class="endofrange" id="I_indexterm10_d1e15107" significance="normal"
          startref="ch10-mavengen">
          <primary></primary>
        </indexterm>et maintenable.</para>
    </sect2>
  </sect1>
  <sect1 id="I_sect110_d1e15110">
    <title id="sect-advanced-builds-coordinating">Coordonner vos
    builds</title>
    <para>Déclencher des tâches avals est assez facile. Toutefois, quand on
    met en place des configurations de tâches de build plus importantes et
    plus compliquées, on aimerait parfois être capable de lancer des
    exécutions simultanées, ou éventuellement attendre la fin de certaines
    tâches de build afin de continuer. Dans cette section, nous allons
    regarder les techniques et les plugins qui peuvent nous aider à faire
    cela.</para>
    <sect2>
      <title>Les builds parallèles dans Jenkins</title>
      <para>Jenkins<indexterm class="startofrange" id="ch10-parallel"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>exécution en parallèle</secondary>
        </indexterm> possède un support intégré pour les build parallèles —
      quand une tâche démarre, Jenkins va lui assigner le premier noeud de
      build disponible. Vous pouvez donc avoir potentiellement autant de
      builds parallèles en exécution que vous avez de noeuds
      disponibles.</para>
      <para>Si vous avez besoin d'exécuter une légère variations de la même
      tâche de build en parallèle, les tâches de build multiconfiguration
      (voir <xref linkend="sect-multi-configuration-build-jobs" />) sont une
      excellente option. Ceci peut s'avérer très pratique comme moyen
      d'accéler votre processus de build. Une application typique des
      tâches de build multiconfiguration dans ce contexte est d'exécuter des
      tests d'intégration en parallèle. Vous pourriez définir des profils
      Maven par exemple, ou configurer votre build pour utiliser des
      paramètres de ligne de commande pour décider quels tests exécuter. Une
      fois que vous avez configuré vos scripts de build de cette façon, il est
      aisé de configurer une tâche de build multiconfiguration pour
      exécuter un sous ensemble de vos tests d'intégration en
      parallèle.</para>
      <para>Vous pouvez aussi faire que Jenkins déclenche plusieurs tâches
      avals en parallèle, en les listant simplement dans le champ "Construire
      d'autres projets" (voir <xref
      linkend="fig-hudson-build-other-projects" />). Les tâches de build
      suivantes seront exécutées en parallèle autant que possible. Toutefois,
      comme nous le verrons plus loin, cela peut ne pas toujours être
      exactement ce dont vous avez besoin.</para>
      <figure float="none" id="fig-hudson-build-other-projects">
        <title>Déclencher plusieurs autres builds après une tâche de
        build</title>
        <mediaobject id="I_mediaobject10_d1e15137">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1030.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1030.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
    <sect2>
      <title>Graphes de dépendance</title>
      <para>Avant<indexterm id="I_indexterm10_d1e15147" significance="normal">
          <primary>tâches de build</primary>
          <secondary>dépendances entre</secondary>
        </indexterm><indexterm id="I_indexterm10_d1e15152"
          significance="normal">
          <primary>plugin Dependency Graph View</primary>
        </indexterm><indexterm id="I_indexterm10_d1e15155"
          significance="normal">
          <primary>plugins</primary>
          <secondary>Dependency Graph View</secondary>
        </indexterm> d'étudier les points les plus fins des buils parallèles,
      il est utile de pouvoir visualiser les relations entre vos tâches de
      build. Le plugin Dependency Graph View analyse vos tâches de build et
      affiche un graphe décrivant les connexions amont et aval entre vos
      tâches. Ce plugin utilise <ulink
      url="http://www.graphviz.org">graphviz</ulink>, que vous aurez besoin
      d'installer sur votre serveur si vous ne l'avez pas déjà.</para>
      <para>Ce plugin ajoute une icône Graphe de dépendance dans le menu
      principal, qui affiche un graphe montrant les relations entre toutes les
      tâches de build dans votre projet (au niveau tableau de bord), ou toutes
      les tâches de build liées à la tâche de build courante (quand vous êtes
      à l'intérieur d'un projet particulier [voir <xref
      linkend="fig-hudson-dependency-graph" />]). De plus, si vous cliquez sur
      une tâche de build dans le graphe, Jenkins vous emmènera directement
      vers la page projet de cette tâche de build.</para>
      <figure float="0" id="fig-hudson-dependency-graph">
        <title>Un graphe de dépendance de tâche de build</title>
        <mediaobject id="I_mediaobject10_d1e15171">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1031.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1031.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
    <sect2>
      <title>Jonctions</title>
      <para>Lors <indexterm class="startofrange" id="ch10-join1"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>jonctions dans</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-join2"
          significance="normal">
          <primary>joins, in build jobs</primary>
        </indexterm>de la configuration de pipelines de builds plus
      compliqués, vous rencontrerez fréquemment des situations où une tâche de
      build ne peut démarrer tant qu'un certain nombre d'autres tâches de
      build ne sont pas terminées, mais que ces tâches amont ne nécessitent
      pas d'être exécutées séquentiellement. Par exemple, dans <xref
      linkend="fig-hudson-dependency-graph" />, imaginez que la tâche de build
      <command moreinfo="none">phoenix-deploy-to-uat</command> ait en fait
      besoin que trois tâches réussissent avant qu'elle puisse être exécutée :
      <command moreinfo="none">phoenix-compatibility-tests</command>, <command
      moreinfo="none">phoenix-load-tests</command>, et <command
      moreinfo="none">phoenix-performance-tests</command>.</para>
      <para>On peut configurer cela en utilisant le plugin Joins, que vous
      devez installer de la façon habituelle via le centre de mise à jour. Une
      fois qu'il est installé, vous configurez une jonction dans la tâche de
      build qui initie le processus de jonction (ici, ce serait <command
      moreinfo="none">phoenix-web-tests</command>). Dans notre exemple, nous
      devons modifier la tâche de build <command
      moreinfo="none">phoenix-web-tests</command> afin qu'elle déclenche en
      premier <command moreinfo="none">phoenix-compatibility-tests</command>,
      <command moreinfo="none">phoenix-load-tests</command>, et <command
      moreinfo="none">phoenix-performance-tests</command>, et ensuite, si ces
      trois réussissent, la tâche de build <command
      moreinfo="none">phoenix-deploy-to-uat</command>.</para>
      <para>Nous le faisons en configurant simplement le champ déclencheur de
      jonction avec le nom de la tâche de build <command
      moreinfo="none">phoenix-deploy-to-uat</command> (voir <xref
      linkend="fig-hudson-build-join" />). Le champ “Construire d'autres
      projets” n'est pas modifié, et liste encore les tâches de build à
      déclencher immédiatement après la tâche courante. Le champ déclencheur de
      jonction contient les tâches de build à lancer une fois que toutes les
      tâches avals immédiates se sont terminées.</para>
      <figure float="0" id="fig-hudson-build-join">
        <title>Configurer une jonction dans la tâche de build
        phoenix-web-tests</title>
        <mediaobject id="I_mediaobject10_d1e15236">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1032.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1032.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Résultat, vous n'avez plus besoin du déclencheur de build original
      pour la tâche de build final, puisque c'est à présent redondant.</para>
      <para>Ce nouveau déroulement apparaît bien dans les graphes de
      dépendance<indexterm class="endofrange" id="I_indexterm10_d1e15245"
          significance="normal" startref="ch10-join1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e15247"
          significance="normal" startref="ch10-join2">
          <primary></primary>
        </indexterm> illustrés dans <xref
      linkend="fig-build-dependency-graph-join" />.</para>
      <figure float="0" id="fig-build-dependency-graph-join">
        <title>Un graphe de dépendance de tâche de build plus
        compliqué</title>
        <mediaobject id="I_mediaobject10_d1e15255">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1033.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1033.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
    <?dbfo-need height=”1in”?>
    <sect2>
      <title>Plugin Locks and Latches</title>
      <para>Dans d'autres <indexterm class="startofrange" id="ch10-locks1"
          significance="normal">
          <primary>tâches de build</primary>
          <secondary>verrouiller les ressources pour</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-locks2"
          significance="normal">
          <primary>verrouiller des ressources pour des tâches de
          build</primary>
        </indexterm>situations, vous pourriez être capable de lancer une série
      de builds en parallèle jusqu'à un certain point, mais certaines tâches
      de build pourraient ne pas pouvoir être lancées en parallèle parce
      qu'elles accèdent à des ressources en concurrence. Bien sûr, des tâches de
      build bien conçues devraient s'efforcer d'être aussi indépendantes que
      possible, mais cela peut parfois être difficile. Par exemple,
      différentes tâches de build peuvent accéder à la même base de données de
      test, ou à des fichiers sur le disque dur, et faire cela simultanément
      pourrait potentiellement compromettre le résultat des tests. Une tâche
      de build de performance pourrait avoir besoin d'un accès exclusif au
      serveur de test, afin d'avoir des résultats cohérents à chaque
      fois.</para>
      <para>Le<indexterm id="I_indexterm10_d1e15277" significance="normal">
          <primary>plugins</primary>
          <secondary>Locks and Latches</secondary>
        </indexterm><indexterm id="I_indexterm10_d1e15282"
          significance="normal">
          <primary>plugin Locks and Latches</primary>
        </indexterm> plugin Locks and Latches vous permet d'une certaine façon
      de contourner ce problème. Ce plugin permet de configuration des
      “verrous” (ndt: locks) pour certaines ressources, de façon similaire aux
      verrous en programmation multithreadée. Supposez, par exemple, dans les
      tâches de build dépeintes dans <xref
      linkend="fig-build-dependency-graph-join" />, que les tests de charge et
      les tests de performance soient exécutés sur un serveur dédié, mais
      qu'une seule tâche de build puisse être exécutée à la fois sur ce
      serveur. Imaginez de plus que les tests de performance pour les autres
      projets soient aussi exécutés sur ce serveur.</para>
      <para>Pour éviter la contention sur le serveur de performance, vous
      pourriez utiliser le plugin Locks and Latches pour mettre en place un
      accès par réservation de "verrou" à ce serveur pour une tâche à un
      instant donné. Premièrement, dans la page de configuration du système,
      vous devez ajouter un nouveau verrou dans la section Verrous (voir <xref
      linkend="fig-jenkins-build-lock" />). Ce verrou sera ensuite disponible
      à toutes les tâches de build sur le serveur.</para>
      <figure float="0" id="fig-jenkins-build-lock">
        <title>Ajouter un nouveau verrou</title>
        <mediaobject id="I_mediaobject10_d1e15295">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1034.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1034.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Ensuite, vous devez configurer chaque tâche de build qui utilisera
      la ressource en contention. Dans la section Environnement de build, vous
      trouverez un champ Verrous. Cochez la case et sélectionnez le verrous
      que vous venez juste de créer (voir <xref
      linkend="fig-jenkins-build-locks" />). Une fois que avez fait cela pour
      chacune des tâches de build qui ont besoin d'accéder à la ressource en
      question, seule une des tâches de build pourra s'exécuter à un
      instant<indexterm class="endofrange" id="I_indexterm10_d1e15304"
          significance="normal" startref="ch10-locks1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e15306"
          significance="normal" startref="ch10-locks2">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e15308"
          significance="normal" startref="ch10-parallel">
          <primary></primary>
        </indexterm> donné.</para>
      <figure float="0" id="fig-jenkins-build-locks">
        <title>Configurer une tâche de build pour utiliser un verrou</title>
        <mediaobject id="I_mediaobject10_d1e15314">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1035.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1035.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
  </sect1>
  <sect1 id="sect-build-pipelines">
    <title>Pipelines de build et promotions</title>
    <para>L'intégration<indexterm class="startofrange" id="ch10-pipe"
        significance="normal">
        <primary>pipelines de build</primary>
      </indexterm><indexterm id="I_indexterm10_d1e15327" significance="normal">
        <primary>pipelines</primary>
        <see>pipelines de build</see>
      </indexterm> continue ne consiste pas simplement à construire et tester
    automatiquement un logiciel, elle peut aussi apporter une aide dans un
    contexte plus large de dévéloppement de produit logiciel et de cycle de
    vie de release. Dans de nombreuses organisation, la vie d'une version
    particulière d'une application ou d'un produit démarre en développement.
    Lorsqu'on l'estime prête, elle est passée à l'équipe d'assurance qualité
    pour la tester. S'ils considèrent la version acceptable, ils la
    transmettent à des utilisateurs sélectionnés pour davantage de tests dans
    un environnement de tests d'acceptation. Si les utilisateurs sont
    contents, elle est envoyée en production. Bien sûr, il y a presque autant
    de variations de cela qu'il y a d'équipes de développement, mais un
    principe commun est que des versions spécifiques sont sélectionnées, selon
    certains critères de qualité, afin d'<indexterm
        id="I_indexterm10_d1e15333" significance="normal">
        <primary>pipelines de build</primary>
        <secondary>promotions dans</secondary>
      </indexterm><indexterm id="I_indexterm10_d1e15338" significance="normal">
        <primary>promotions</primary>
      </indexterm>être “promues" à l'étape suivante du cycle de vie. Ceci est
    connu sous l'appellation promotion de build, et le processus plus global
    est connu sous le nom de pipeline de build. Dans cette section, nous
    regarderons comment implémenter des pipelines de build en utilisant
    Jenkins.</para>
    <sect2 id="jenkins-maven-releases">
      <title>Gestion des releases Maven avec le plugin M2Release</title>
      <para>Une part importante de tout pipeline de build est d'avoir une
      stratégie de release bien définie. Ceci implique, entre autres choses,
      de dédier comment et quand lancer une nouvelle release, et comment
      l'identifier avec un libellé unique ou numéro de version. Si <indexterm
          class="startofrange" id="ch10-numbers1" significance="normal">
          <primary>pipelines de build</primary>
          <secondary>numéros de versions Maven pour</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-numbers2"
          significance="normal">
          <primary>Maven</primary>
          <secondary>numéro de version pour</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-numbers3"
          significance="normal">
          <primary>numéros de version, Maven</primary>
        </indexterm>vous travaillez avec des projets Maven, utiliser
      <indexterm id="I_indexterm10_d1e15361" significance="normal">
          <primary>plugins</primary>
          <secondary>Maven Release</secondary>
        </indexterm><indexterm id="I_indexterm10_d1e15366"
          significance="normal">
          <primary>Maven Release plugin</primary>
        </indexterm>le plugin Maven Release pour gérer les numéros de versions
      est une pratique hautement recommandée.</para>
      <para>Les projets Maven utilisent des numéros de version bien définis et
      bien structurés. Un numéro de version typique est composé de trois
      digits (e.g., “1.0.1”). Les développeurs travaillent sur des versions
      SNAPSHOT (e.g.,“1.0.1-SNAPSHOT”), qui, comme son nom l'indique, n'est
      pas conçu pour être définitif. Les releases définitives (e.g., “1.0.1”)
      sont construites une seule fois et déployées dans le dépôt local
      d'entreprise (ou le dépôt central Maven pour les bibliothèques
      opensource), où elles peuvent à leur tour être utilisées par d'autres
      projets. Les numéros de version utilisés dans des artefacts Maven sont
      une part critique du système de gestion de dépendances Maven, et il est
      fortement conseillé de respecter les conventions Maven.</para>
      <para>Le plugin Maven Release aide à automatiser le processus de mise à
      jour des numéros de version Maven de vos projets. En résumé, cela
      vérifie, construit et teste votre application, monte les numéros de
      version, met à jour votre système de contrôle de versions avec les tags
      appropriés, et déploie les versions de release de vos artefacts dans
      votre dépôt Maven. C'est une tâche fastidieuse à faire manuellement, le
      plugin Maven Release est donc un excellent moyen d'automatiser les
      choses.</para>
      <para>Toutefois, le plugin Maven Release peut aussi être capricieux. Des
      fichiers locaux non-archivés ou modifiés peuvent faire échouer le
      processus, par exemple. Le processus est aussi consommateur en temps et
      consomme intensivement le CPU, plus spécialement pour les gros projets :
      cela construit et exécute entièrement l'ensemble de tests unitaires et
      d'intégration plusieurs fois, récupère une copie propre du code depuis
      le dépôt, et envoie plusieurs artefacts au dépôt d'entreprise.
      Concrètement, ce n'est pas le genre de chose que vous voulez exécuter sur
      une machine de développeur.</para>
      <para>Il est donc de bon ton d'exécuter ce processus sur votre serveur
      de build.</para>
      <para>Une façon de faire cela est de configurer une tâche manuelle de
      build spéciale invoquant le plugin Maven Release. Toutefois, le plugin
      M2Release propose une approche plus simple. En utilisant ce plugin, vous
      pouvez ajouter la possibilité de construire une version de release Maven
      à une tâche existante. Vous pouvez ainsi éviter de dupliquer des tâches
      de builds inutilement, facilitant par la même la maintenance du
      serveur.</para>
      <para>Une fois ce plugin installé, vous pouvez configurer toute tâche de
      build pour qu'elle propose une étape manuelle de release Maven. Ceci
      s'effectue en cochant la case “Maven release build” dans la section
      Environnement de Build (voir <xref
      linkend="fig-build-m2release-plugin" />). Ici, vous définissez les goals
      que vous voulez exécuter pour le build (typiquement <literal
      moreinfo="none">release:prepare release:perform</literal>).</para>
      <figure float="none" id="fig-build-m2release-plugin">
        <title>Configurer une release Maven en utilisant le plugin
        M2Release</title>
        <mediaobject id="I_mediaobject10_d1e15393">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1036.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1036.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Lorsque ceci est configuré, vous pouvez déclencher manuellement
      une release Maven en utilisant une nouvelle option de menu appelée
      “Perform Maven Release” (voir <xref
      linkend="fig-jenkins-m2-release-menu" />).</para>
      <figure float="none" id="fig-jenkins-m2-release-menu">
        <title>L'option de menu Perform Maven Release</title>
        <mediaobject id="I_mediaobject10_d1e15405">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1037.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1037.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Cela déclenchera une tâche de build spéciale utilisant les goals
      que vous avez fournis dans la configuration du plugin (voir <xref
      linkend="fig-jenkins-perform-release" />). Jenkins vous offre le choix
      d'utiliser soit les numéros de version par défaut fournis par Maven (par
      exemple, la version 1.0.1-SNAPSHOT sera livrée avec la version 1.0.1, et le numéro de
      version en développement sera positionnée à 1.0.2-<phrase
      role="keep-together">SNAPSHOT</phrase>), soit de fournir vos propres
      numéros de version personnalisés. Si, par exemple, vous voulez livrer une version
      majeure vous pourriez décider de spécifier manuellement
      1.1.0 comme numéro de version et 1.1.1-SNAPSHOT comme prochain numéro de
      version de développement.</para>
      <para>Si vous avez un projet multimodule Maven, vous pouvez choisir une
      configuration de numéro de version unique pour tous les modules, ou de
      fournir une mise à jour de numéro de version différente pour chaque
      module. Notez que ce n'est généralement pas une pratique recommandée que
      de fournir des numéros de version différents pour différents modules
      dans un projet multimodule.</para>
      <figure float="none" id="fig-jenkins-perform-release">
        <title>Effectuer une release Maven dans Jenkins</title>
        <mediaobject id="I_mediaobject10_d1e15423">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1038.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1038.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>En fonction de votre configuration SCM, vous pourriez aussi avoir
      besoin de fournir un nom d'utilisateur et un mot de passe valide pour
      permettre à Maven de créer les tags dans votre dépôt de code
      source.</para>
      <para>L'<indexterm id="I_indexterm10_d1e15432" significance="normal">
          <primary>Nexus</primary>
          <secondary>Gestionnaire de Dépôts d'Entreprise</secondary>
        </indexterm>édition professionnelle du Dépôt d'Entreprise Nexus
      fournit une fonctionnalité appelée Staging Repositories, qui permet
      de déployer des artefacts dans un espace spécial de staging afin de
      faire davantage de tests avant de les livrer officiellement. Si vous
      utilisez cette fonctionnalité, vous devez paramétrer plus finement votre
      configuration de serveur de build pour de meilleurs résultats.</para>
      <para>Nexus Professional travaille en créant un nouvel espace de staging
      pour chaque adresse IP unique, utilisateur de déploiement et User-Agent
      HTTP. Une machine de build Jenkins donnée aura toujours la même adresse
      IP et le même utilisateur. Toutefois, vous voudrez typiquement avoir un
      espace de staging séparé pour chaque build. L'astuce est alors de
      configurer Maven pour qu'il utilise une chaîne de User-Agent HTTP unique
      pour le processus de déploiement. Vous pouvez le faire en configurant le
      fichier <filename moreinfo="none">settings.xml</filename> sur votre
      serveur de build afin qu'il contienne quelque chose dans le genre des
      lignes suivantes (l'ID doit correspondre à l'ID du dépôt de release de
      la section <emphasis>deployment</emphasis> <indexterm class="endofrange"
          id="I_indexterm10_d1e15443" significance="normal"
          startref="ch10-numbers1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e15445"
          significance="normal" startref="ch10-numbers2">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e15447"
          significance="normal" startref="ch10-numbers3">
          <primary></primary>
        </indexterm> de votre projet) :</para>
      <?dbfo-need height=”1in”?>
      <programlisting format="linespecific" id="I_programlisting10_d1e15451"> &lt;server&gt;
    &lt;id&gt;nexus&lt;/id&gt;
    &lt;username&gt;my_login&lt;/username&gt;
    &lt;password&gt;my_password&lt;/password&gt;
    &lt;configuration&gt;
      &lt;httpHeaders&gt;
        &lt;property&gt;
          &lt;name&gt;User-Agent&lt;/name&gt;
          &lt;value&gt;Maven m2Release (java:${java.vm.version} ${env.BUILD_TAG }&lt;/value&gt;
        &lt;/property&gt;
      &lt;/httpHeaders&gt;
    &lt;/configuration&gt;
  &lt;/server&gt;</programlisting>
    </sect2>
    <sect2 id="sect-copying-artifacts">
      <title>Copier des artefacts</title>
      <para>Pendant<indexterm class="startofrange" id="ch10-art1"
          significance="normal">
          <primary>pipelines de build</primary>
          <secondary>réutiliser des artefacts dans</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-art2"
          significance="normal">
          <primary>artefacts binaires</primary>
          <secondary>réutiliser dans des pipelines de build</secondary>
        </indexterm><indexterm id="I_indexterm10_d1e15468"
          significance="normal">
          <primary>artifacts</primary>
          <see>artefacts binaires</see>
        </indexterm> un processus de build impliquant plusieurs tâches de
      build, comme celle illustrée dans <xref
      linkend="fig-build-dependency-graph-join" />, il peut parfois être utile
      de réutiliser des artefacts produits par un build dans une tâche de
      build ultérieure. Par exemple, vous pourriez vouloir exécuter une série
      de tests web en parallèles sur des machines séparées, en utilisant des
      serveurs d'application locaux pour améliorer les performances. Dans ce
      cas, il est normal de récupérer le binaire exact qui a été produit dans
      le build précédent, plutôt que de le reconstruire chaque fois ou, si
      vous utilisez Maven, de reposer sur un build SNAPSHOT déployé dans le
      dépôt d'entreprise. En effet, ces deux approches pourraient vous faire
      courir le risque de résultats de build incohérent : si vous utilisez une
      SNAPSHOT d'un dépôt d'entreprise, par exemple, vous utiliserez le
      dernier build SNAPSHOT, qui pourrait ne pas nécessairement être celui
      construit dans la tâche de build amont.</para>
      <para>Le <indexterm id="I_indexterm10_d1e15478" significance="normal">
          <primary>plugins</primary>
          <secondary>Copy Artifact</secondary>
        </indexterm><indexterm id="I_indexterm10_d1e15483"
          significance="normal">
          <primary>plugin Copy Artifact</primary>
        </indexterm> plugin Copy Artifact vous permet de copier des artefacts
      d'un build amont et de les réutiliser dans votre build courant. Une fois
      que vous avez installé ce plugin et redémarré Jenkins, vous pourrez
      ajouter une nouvelle étape de build appelée “Copier des artefacts d'un
      autre projet” à vos tâches de build freestyle (voir <xref
      linkend="fig-build-copy-artifacts" />).</para>
      <figure float="none" id="fig-build-copy-artifacts">
        <title>Ajouter une étape de build “Copier des artefacts d'un autre
        projet”</title>
        <mediaobject id="I_mediaobject10_d1e15492">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1039.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1039.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Cette nouvelle étape de build vous permet de copier des artefacts
      d'un projet dans l'espace de travail du projet courant. Vous pouvez
      spécifier n'importe quel autre projet, bien que ce sera typiquement
      l'une des tâches de build amont. Et bien sûr vous pouvez spécifier, avec
      une grande flexibilité et précision, les artefacts exacts que vous
      souhaitez copier.</para>
      <para>Vous devez spécifier où trouver les fichiers que vous voulez dans
      l'espace de travail de l'autre tâche de build, et où Jenkins doit les
      mettre dans votre espace de travail courant. Ceci peut être une
      expression régulière flexible (comme <literal
      moreinfo="none">**/*.war</literal>, pour tout fichier WAR produit par la
      tâche de build), ou cela peut être beaucoup plus précis (comme <literal
      moreinfo="none">gameoflife-web/target/gameoflife.war</literal>). Notez
      que par défaut, Jenkins copiera la structure de répertoire en même temps
      que le fichier que vous récupérez, ainsi si le fichier WAR se trouve
      dans dans le répertoire <filename moreinfo="none">target</filename> du module <literal
      moreinfo="none">gameoflife-web</literal>, Jenkins le placera dans le
      répertoire <filename moreinfo="none">gameoflife-web/target</filename> de
      votre espace de travail courant. Si cela ne vous convient pas, vous
      pouvez cocher l'option “Aplatir l'arborescence” pour dire à Jenkins de
      mettre tous les artefacts à la racine du répertoire que vous spécifiez
      (ou, par défaut, dans l'espace de travail de votre projet).</para>
      <para>Souvent, vous voudrez simplement récupérer des artefacts depuis le
      build réussi le plus récent. Toutefois, vous voudrez parfois plus de
      précision. Le champ "Quel build” vous permet de spécifier où chercher
      des artefacts d'un bon nombre d'autres façons, incluant le dernier build
      sauvé (builds qui ont été marqués à "toujours conserver"), le dernier
      build réussi, ou même un numéro spécifique de build.</para>
      <para>Si vous avez installé le plugin Build Promotion (voir <xref
      linkend="sect-build-promotion" />), vous pouvez aussi sélectionner le
      dernier artefact promu dans un processus de promotion en particulier.
      Pour faire cela, choisissez "Spécifier par permalien", puis choisissez
      le processus de promotion de build approprié. C'est un excellent moyen
      de s'assurer d'un pipeline de build fiable et cohérent. Par exemple,
      vous pouvez configurer un processus de promotion de build pour
      déclencher un build qui copie un fichier WAR généré depuis le dernier
      build promu et le déploie sur un serveur particulier. Ceci vous assure
      de déployer le bon fichier binaire, même si d'autres builds se sont
      produits depuis.</para>
      <para>Si vous copiez des artefacts d'une tâche de build multimodule
      Maven, Jenkins copiera, par défaut, tous les artefacts de ce build.
      Toutefois vous êtes souvent intéressé uniquement par un artefact
      spécifique (comme l'artefact WAR pour une application web, par
      exemple).</para>
      <para>Ce plugin est particulièrement utile quand vous avez besoin
      d'exécuter des tests fonctionnels ou de performance sur votre
      application web. Il est souvent stratégiquement utile de placer ces tests
      dans un projet séparé, et non comme une partie de votre processus de
      build principal. Cela facilite l'exécution de ces tests sur différents
      serveurs ou d'exécuter le sous-ensemble des tests en parallèle, tout en
      utilisant le même artefact binaire pour déployer et tester.</para>
      <para>Par exemple, imaginez que vous avez une tâche de build par défaut
      appelée <emphasis>gameoflife</emphasis> qui génère un fichier WAR, et
      que vous vouliez déployer ce WAR sur un serveur d'application local et
      exécuter une série de tests fonctionnels. De plus, vous voulez pouvoir
      faire cela en parallèle sur plusieurs machines distribuées.</para>
      <para>Une façon de faire cela serait de créer un projet Maven dédié pour
      lancer les tests fonctionnels sur un serveur arbitraire. Ensuite, vous
      mettriez en place une tâche de build pour exécuter ces tests
      fonctionnels. La tâche de build utiliserait le plugin Copy Artifact pour
      récupérer le dernier fichier WAR (ou même le dernier fichier WAR promu,
      pour plus de précision), et le déploierait sur une instance Tomcat
      locale en utilisant Cargo. Cette tâche de build pourrait ensuite être
      configurée en tant que tâche de build (“matrix”) configurable, et
      exécutée en parallèle sur plusieurs machines, éventuellement avec des
      paramètres de configuration supplémentaires pour filtrer les exécutions
      de test de chaque build. Chaque exécution de build utiliserait ensuite
      sa propre copie du fichier WAR original. Un exemple d'une configuration
      comme celle-ci est illustré dans <xref
      linkend="fig-jenkins-copy-artifact-web" />.</para>
      <figure float="none" id="fig-jenkins-copy-artifact-web">
        <title>Exécuter des tests web sur un fichier WAR copié</title>
        <mediaobject id="I_mediaobject10_d1e15539">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1040.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1040.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Le plugin Copy Artifact n'est pas restreint à la récupération de
      fichiers depuis des tâches de build conventionnelles. Vous pouvez aussi
      copier des artefacts à partir de tâches de build multiconfiguration
      (voir <xref linkend="sect-multi-configuration-build-jobs" />). Les
      artefacts de chaque configuration exécutée seront copiés dans l'espace
      de travail courant, chacun dans son propre répertoire. Jenkins
      construira une structure de répertoire en se basant sur les axes
      utilisés dans le build multiconfiguration. Par exemple, imaginez que
      nous ayons besoin de produire une version hautement optimisée de notre
      produit pour un certain nombre de bases de données et de serveurs
      d'application cibles. Nous pourrions faire cela avec une tâche de build
      multiconfiguration comme celle illustrée dans <xref
      linkend="fig-jenkins-multi-config-artifacts" />.</para>
      <figure float="0" id="fig-jenkins-multi-config-artifacts">
        <title>Copier à partir d'un build multiconfiguration</title>
        <mediaobject id="I_mediaobject10_d1e15553">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1041.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1041.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Le plugin Copy Artifacts peut dupliquer n'importe lequel ou même
      tous les artefacts produits par cette tâche de build. Si vous spécifiez
      un build multiconfiguration comme source de vos artefacts, le plugin
      copiera les artefacts de toutes les configurations dans l'espace de
      travail de la tâche de build cible, en utilisant une structure de
      répertoire imbriquée basée sur les axes du build multiconfiguration. Par
      exemple, si vous définissez le répertoire cible comme <filename
      moreinfo="none">multi-config-artifacts</filename>, Jenkins copiera les
      artefacts dans un certain nombre de sous-répertoires dans le répertoire
      cible, chacun avec un nom correspondant à un ensemble particulier de 
      paramètres. Ainsi, en utilisant la tâche de build illustrée dans <xref
      linkend="fig-jenkins-multi-config-artifacts" />, le fichier JAR
      personnalisé pour Tomcat et MySql serait copié<indexterm
          class="endofrange" id="I_indexterm10_d1e15565" significance="normal"
          startref="ch10-art1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e15567"
          significance="normal" startref="ch10-art2">
          <primary></primary>
        </indexterm> dans le répertoire <filename moreinfo="none">
      $WORKSPACE/multi-config-artifacts/APP_SERVER/tomcat/DATABASE/mysql</filename>.</para>
    </sect2>
    <sect2 id="sect-build-promotion">
      <title>Promotions de build</title>
      <para>Dans le <indexterm class="startofrange" id="ch10-promote1"
          significance="normal">
          <primary>pipelines de build</primary>
          <secondary>promotions dans</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-promote2"
          significance="normal">
          <primary>promotions</primary>
        </indexterm>monde de l'Intégration Continue, tous les builds créés ne
      sont pas égaux. Par exemple, vous pourriez vouloir déployer la dernière
      version de votre application web sur un serveur de test, mais seulement
      après avoir réussi un certain nombre de tests fonctionnels automatisés
      ou de charge. Ou vous pourriez vouloir que les testeurs puissent marquer
      certains builds comme étant prêts pour un déploiement pour les tests
      d'acceptation utilisateur, une fois qu'ils ont terminé leurs propres
      tests.</para>
      <para>Le plugin<indexterm id="I_indexterm10_d1e15589"
          significance="normal">
          <primary>plugins</primary>
          <secondary>Promoted Builds</secondary>
        </indexterm><indexterm id="I_indexterm10_d1e15594"
          significance="normal">
          <primary>plugin Promoted Builds</primary>
        </indexterm> Promoted Builds vous permet d'identifier des builds
      spécifiques ayant atteint des critères additionnels de qualité, et de
      déclencher des actions sur ces builds. Par exemple, vous pourriez
      construire une application web dans une tâche de build, exécuter une
      série de tests automatisés dans un build ultérieur, puis déployer le
      fichier WAR généré sur le serveur de tests d'acceptation utilisateur
      pour effectuer davantage de tests.</para>
      <para>Voyons comment cela fonctionne en pratique. Dans le projet
      illustré ci-dessus, une tâche de build par défaut (<command
      moreinfo="none">phoenix-default</command>) exécute des tests unitaires
      et d'intégration, puis produit un fichier WAR. Ce fichier WAR est ensuite
      réutilisé pour des tests plus étendus (dans la tâche de build <command
      moreinfo="none">phoenix-integration-tests</command>) et ensuite pour une
      série de tests web automatisés (dans la tâche de build <command
      moreinfo="none">phoenix-web-test</command>). Si le build réussit les
      tests web automatisés, nous aimerions déployer l'application dans un
      environnement de tests fonctionnels où elle pourrait être testée par des
      testeurs humains. Le déploiement dans cet environnement est effectué
      avec la tâche de build <command
      moreinfo="none">phoenix-test-deploy</command>. Une fois que les testeurs
      ont validé la version, elle peut être promue vers l'environnement de tests
      d'acceptation utilisateur, et enfin en production. La stratégie
      complète de promotion est illustrée dans <xref
      linkend="fig-jenkins-build-promotion-jobs" />.</para>
      <figure float="none" id="fig-jenkins-build-promotion-jobs">
        <title>Tâches de build dans le processus de promotion</title>
        <mediaobject id="I_mediaobject10_d1e15617">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1042.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1042.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Cette stratégie est facile à implémenter en utiliser le plugin
      Promoted Builds. Une fois que vous l'avez installé de la façon
      habituelle, vous trouverez une nouvelle case "Promouvoir builds quand"
      dans la page de configuration de la tâche. Cette option est utilisé pour
      configurer les processus de promotion de build. Vous définissez un ou
      plusieurs processus de promotion de build dans la tâche de build
      initiale du processus (<command
      moreinfo="none">phoenix-default</command> dans cet exemple), comme
      illustré dans <xref linkend="fig-jenkins-build-promotion" />. Une tâche
      de build peut être le point de départ de plusieurs processus de
      promotion de build, certains automatisés, certains manuels. Dans <xref
      linkend="fig-jenkins-build-promotion" />, par exemple, il y a un
      processus de promotion de build automatisé appelé
      <emphasis>promote-to-test</emphasis> et un manuel appelé
      <emphasis>promote-to-uat</emphasis>. Les processus de promotion de build
      automatisés sont déclenchés par les résultats de tâches de build avals.
      Les processus de promotion manuels (indiqués en cochant la case
      ‘Seulement si approuvé manuellement’) peuvent uniquement être déclenchés
      par une intervention utilisateur.</para>
      <figure float="none" id="fig-jenkins-build-promotion">
        <title>Configurer un processus de promotion de build</title>
        <mediaobject id="I_mediaobject10_d1e15644">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1043.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1043.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Regardons à présent comment configurer le processus de build
      automatisé <emphasis>promote-to-test</emphasis>.</para>
      <para>Vous devez commencer par définir comment le processus de promotion
      de build sera déclenché. La promotion de build peut être soit
      automatique, basée sur le résultat d'une tâche de build aval, soit
      activée manuellement par un utilisateur. Dans <xref
      linkend="fig-jenkins-build-promotion" />, la promotion de build pour
      cette tâche de build sera automatiquement déclenchée lorsque les tests
      web automatisés (exécuté par la tâche de build <command
      moreinfo="none">phoenix-web-tests</command>) auront réussi.</para>
      <para>Vous pouvez aussi faire que certaines tâches de build ne puissent
      être promues que manuellement, comme illustré dans <xref
      linkend="fig-jenkins-manual-build-promotion" />. La promotion de build
      manuelle est utilisée pour les cas où une intervention humaine est
      requise pour approuver une promotion de build. Le déploiement dans
      l'environnement de test d'acceptation utilisateur ou de production
      en sont des exemples courants. Autre exemple, lorsque vous
      voulez suspendre temporairement les promotions de build pour une courte
      période, comme à l'approche d'une release.</para>
      <para>Les builds manuels, comme leur nom le suggère, nécessite d'être
      approuvés manuellement avant de pouvoir être exécutés. Si le processus
      de promotion consiste à déclencher une tâche de build paramétrée, vous
      pouvez aussi fournir des paramètres que l'approbateur devra entrer lors
      de l'approbation. Dans certains cas, il peut être utile de désigner certains
      utilisateurs autorisés à activer la promotion manuelle. Vous pouvez
      faire cela en spécifiant une liste d'utilisateurs ou de groupes dans la
      liste d'approbateurs.</para>
      <figure float="0" id="fig-jenkins-manual-build-promotion">
        <title>Configurer un processus manuel de promotion de build</title>
        <mediaobject id="I_mediaobject10_d1e15671">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1044.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1044.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Parfois, il est utile de donner un peu de context à une personne
      approuvant une promotion. Quand vous configurez un processus de
      promotion manuel, vous pouvez aussi spécifier d'autres conditions devant
      être remplies, en particulier des tâches de build avals (ou amonts) qui
      doivent avoir été construites avec succès (voir <xref
      linkend="fig-jenkins-promotion-details" />). Celles-ci apparaîtront dans
      les “Met Qualifications” (pour les tâches de build en succès) et dans
      les “Unmet Qualifications” (pour les tâches de builds qui ont échoué ou
      n'ont pas encore été exécutées).</para>
      <figure float="0" id="fig-jenkins-promotion-details">
        <title>Voir les détails d'une promotion de build</title>
        <mediaobject id="I_mediaobject10_d1e15683">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1045.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1045.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Vous devez ensuite dire à Jenkins ce qu'il doit faire lorsque le
      build est promu. Cela se fait en ajoutant des actions, tout comme dans
      une tâche de build freestyle. Ceci rend les promotions de build
      extrêmement flexible, parce que vous pouvez ajouter pratiquement
      n'importe quelle action disponible dans une tâche de build freestyle
      normale, incluant n'importe quelles étapes additionnelles offertes par
      le plugins installés sur votre instance Jenkins. Les actions courantes
      incluent l'invocation de script Maven ou Ant, le déploiement d'artefacts
      dans un dépôt Maven, ou le déclenchement d'un autre build.</para>
      <para>Une chose importante à garder à l'esprit ici est que vous ne
      pouvez pas vous reposer sur des fichiers de l'espace de travail lors de la
      promotion de votre build. En effet, au moment où vous promouvez votre
      build, automatiquement ou manuellement, d'autres tâches de build
      pourraient avoir supprimé ou réécrit les fichiers que vous avez besoin
      d'utiliser. Pour cette raison, il est imprudent, par exemple, de
      déployer un fichier WAR directement à partir de l'espace de travail vers
      un serveur d'application pendant un processus de promotion de build. Une
      solution plus robuste consiste à déclencher une tâche de build séparée
      et d'utiliser le plugin Copy Artifacts (voir <xref
      linkend="sect-copying-artifacts" />) pour récupérer précisément le bon
      fichier. Dans ce cas, vous copierez des artefacts que vous avez demandé
      à Jenkins de conserver, plutôt que de copier directement des fichiers de
      l'espace de travail.</para>
      <para><indexterm id="I_indexterm10_d1e15695" significance="normal">
          <primary>fingerprints</primary>
        </indexterm>Pour que la promotion de build fonctionne correctement,
      Jenkins doit pouvoir lier précisément les tâches de build avals à celles
      en amont. La façon la plus précise de faire cela est d'utiliser les
      <emphasis>fingerprints</emphasis>. Dans Jenkins, un fingerprint est le
      somme de contrôle MD5 d'un fichier produit ou utilisé dans une tâche de
      build. En faisant correspondre les fingerprints, Jenkins est capable
      d'identifier tous les builds utilisant un fichier particulier.</para>
      <para>Dans le contexte de la promotion de build, une stratégie courante
      est de construire votre application une seule fois, puis d'exécuter des
      tests sur les fichiers binaires générés dans une série de tâches de
      builds avals. Cette approche fonctionne bien avec la promotion de build,
      mais vous devez vous assurer que Jenkins créer un fingerprint des
      fichiers partagés ou copiés entre tâches de build. Dans l'exemple montré
      dans <xref linkend="fig-jenkins-build-promotion" />, notamment, nous
      avons besoin de faire deux choses (<xref
      linkend="fig-jenkins-build-promotion-fingerprints" />). Premièrement,
      nous devons archiver le fichier WAR généré afin qu'il puisse être
      utilisé dans le projet aval. Deuxièmement, nous devons enregistrer un
      fingerprint des artefacts archivés. Vous faites cela en cochant l'option
      “Enregistrer les fingerprints de fichiers pour tracer leur utilisation”,
      et en spécifiant les fichiers pour lesquels vous voulez créer un
      fingerprint. Un raccourci utile consiste simplement à créer un
      fingerprint pour tous les fichiers archivés, puisque ce sont les
      fichiers qui vont typiquement être récupérés et réutilisés par les
      tâches de build avals.</para>
      <figure float="0" id="fig-jenkins-build-promotion-fingerprints">
        <title>Utiliser fingerprints dans le processus de promotion de
        build</title>
        <mediaobject id="I_mediaobject10_d1e15708">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1046.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1046.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>C'est tout ce que vous avez besoin de faire pour configurer le
      processus initial de build. L'étape suivante consiste à configurer les
      tests d'intégration exécutés dans la tâche de build <command
      moreinfo="none">phoenix-integration</command>. Ici, nous utilisons le
      plugin Copy Artifact pour récupérer le WAR généré par la tâche de build
      <phrase role="keep-together"><command
      moreinfo="none">phoenix-default</command></phrase> (voir <xref
      linkend="fig-jenkins-build-promotion-integration" />). Comme cette tâche
      de build est déclenchée immédiatement après la tâche de build <command
      moreinfo="none">phoenix-default</command>, on peut simplement récupérer
      le fichier WAR depuis le dernier build réussi.</para>
      <figure float="none" id="fig-jenkins-build-promotion-integration">
        <title>Récupérer le fichier WAR depuis la tâche de build amont</title>
        <mediaobject id="I_mediaobject10_d1e15730">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1047.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1047.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Cependant, ce n'est pas encore tout à fait tout ce que nous devons faire pour
      les tests d'intégration. La tâche de build <command
      moreinfo="none">phoenix-integration</command> est suivie de la tâche de
      build <command moreinfo="none">phoenix-web</command>, qui exécute les
      tests web automatisés. Pour s'assurer que le même fichier WAR est
      utilisé à chaque étape du processus de build, nous devons le récupérer
      dans la tâche de build amont <command
      moreinfo="none">phoenix-integration</command>, et non depuis la tâche
      originale <command moreinfo="none">phoenix-default</command> (qui
      pourrait avoir été exécutée à nouveau dans l'intervalle). Nous avons
      donc aussi besoin d'archiver le fichier WAR dans la tâche de build
      <command moreinfo="none">phoenix-integration</command> (voir <xref
      linkend="fig-jenkins-promotion-integration-archive" />).</para>
      <figure float="0" id="fig-jenkins-promotion-integration-archive">
        <title>Archiver le fichier WAR dans la tâche aval</title>
        <mediaobject id="I_mediaobject10_d1e15759">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1048.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1048.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Dans la tâche de build <command
      moreinfo="none">phoenix-web</command>, nous récupérons ensuite le WAR
      depuis la tâche <phrase role="keep-together"><command
      moreinfo="none">phoenix-integration</command></phrase>, en utilisant une
      configuration très similaire à celle montrée ci-dessus (voir <xref
      linkend="fig-jenkins-promotion-copy-from-integration" />).</para>
      <figure float="none" id="fig-jenkins-promotion-copy-from-integration">
        <title>Récupérer le fichier WAR depuis la tâche d'intégration</title>
        <mediaobject id="I_mediaobject10_d1e15778">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1049.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1049.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Pour que le processus de promotion de build fonctionne
      correctement, il y a une chose importante de plus que nous devons
      configurer dans la tâche de build <command
      moreinfo="none">phoenix-web</command>. Comme nous l'avons évoqué
      précédemment, Jenkins a besoin de pouvoir être sûr que le fichier WAR
      utilisé dans ces tests est le même que celui généré dans le build
      original. Nous faisons cela en activant la création de fingerprint sur
      le fichier WAR que nous avons récupéré depuis la tâche de build <command
      moreinfo="none">phoenix-integration</command> (qui, rappelez-vous, a
      originellement été construit par la tâche <command
      moreinfo="none">phoenix-default</command>). Comme nous avons copié ce
      fichier WAR dans l'espace de travail, une configuration comme celle de
      <xref linkend="fig-jenkins-promotion-fingerprint-web" /> fonctionnera
      très bien.</para>
      <figure float="none" id="fig-jenkins-promotion-fingerprint-web">
        <title>Nous avons besoin de déterminer le fingerprint du fichier WAR
        que nous utilisons</title>
        <mediaobject id="I_mediaobject10_d1e15799">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1050.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1050.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>L'étape final consiste à configurer la tâche de build <command
      moreinfo="none">phoenix-deploy-to-test</command> pour récupérer le
      dernier WAR promu (plutôt que le dernier réussi). Pour faire
      cela, nous utilisons à nouveau le plugin Copy Artifact, mais cette fois
      nous choisissons l'option "Spécifier par permalien". Ici, Jenkins
      proposera, entre autres choses, les processus de promotion de build configurés pour
      la tâche de build à partir de laquelle vous êtes en train de copier.
      Donc, dans <xref linkend="fig-jenkins-copy-promoted-war" />, nous
      récupérons le dernier fichier WAR promu par la tâche <command
      moreinfo="none">phoenix-default</command>, ce qui est précisément ce que
      nous voulons.</para>
      <figure float="none" id="fig-jenkins-copy-promoted-war">
        <title>Récupérer le dernier fichier WAR promu</title>
        <mediaobject id="I_mediaobject10_d1e15817">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1051.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1051.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Notre processus de promotion est maintenant prêt pour l'action.
      Quand les tests web automatisés réussiront lors d'un build particulier,
      la tâche de build originale sera promu et le fichier WAR correspondant
      déployé dans l'environnement de test. Les builds promus sont indiqués
      par une étoile dans l'historique de build (voir <xref
      linkend="fig-jenkins-promoted-build-history" />). Par défaut, les
      étoiles sont jaunes, mais vous pouvez configurer la couleur de l'étoile
      dans la configuration de la promotion de build.</para>
      <figure float="0" id="fig-jenkins-promoted-build-history">
        <title>Les builds promus sont indiqués par une étoile dans
        l'historique de build</title>
        <mediaobject id="I_mediaobject10_d1e15829">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1052.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1052.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Vous pouvez aussi utiliser l'entrée de menu “Etat de Promotion”
      (ou cliquez sur l'étoile colorée dans l'historique de build) pour voir
      les détails d'une promotion de build particulière, et même de réexécuter
      manuellement une promotion (voir <xref
      linkend="fig-jenkins-promotion-details" />). Toute promotion de build
      peut être déclenchée manuellement, en cliquant sur "Forcer la promotion"
      (si cette tâche de build n'a jamais été promue) <indexterm
          class="endofrange" id="I_indexterm10_d1e15838" significance="normal"
          startref="ch10-promote1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e15840"
          significance="normal" startref="ch10-promote2">
          <primary></primary>
        </indexterm>ou “Ré-exécuter la promotion” (si elle l'a été).</para>
    </sect2>
    <sect2>
      <title>Agréger des résultats de tests</title>
      <para>Lorsqu'<indexterm class="startofrange" id="ch10-agg1"
          significance="normal">
          <primary>pipelines de build</primary>
          <secondary>agréger les résultats de tests d'un</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-agg2"
          significance="normal">
          <primary>tests</primary>
          <secondary>rapport de</secondary>
          <tertiary>agrégation</tertiary>
        </indexterm><indexterm class="startofrange" id="ch10-agg3"
          significance="normal">
          <primary>agréger résultats tests</primary>
        </indexterm><indexterm class="startofrange" id="ch10-agg4"
          significance="normal">
          <primary>reporting</primary>
          <secondary>résultats de test</secondary>
          <tertiary>agréger</tertiary>
        </indexterm>on répartit différents types de tests dans différentes
      tâches de build, il est facile de perdre la vision globale des résultats
      de tests de l'ensemble. Ces résultats sont dispersés parmi les diverses
      tâches de build, sans un endroit central où voir le nombre total de
      tests exécutés et échoués.</para>
      <para>Un bon moyen d'éviter ce problème est d'utiliser la fonctionnalité
      d'agrégation de résultats de tests de Jenkins. Ceci récupérera tout
      résultat de test depuis les tâches de build avals, et les agrégera dans
      la tâche de build amont. Vous pouvez configurer cela dans la tâche de
      build initiale (amont) en cochant l'option "Agréger les résultat de test
      avals" (voir <xref
      linkend="fig-jenkins-aggregate-downstream-tests" />).</para>
      <figure float="0" id="fig-jenkins-aggregate-downstream-tests">
        <title>Rapport sur l'agrégation des résultats de test</title>
        <mediaobject id="I_mediaobject10_d1e15878">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1053.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1053.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Les résultats de test agrégés peuvent être consultés dans la page
      de détails du build (voir <xref
      linkend="fig-jenkins-show-aggregate-tests" />). Malheureusement, ces
      résultats de test agrégés n'apparaissent pas dans les résultats de test
      globaux, mais vous pouvez afficher la liste complète des tests exécutés
      en cliquant sur le lien Résultats de Test Agrégés sur la page du build
      particulier.</para>
      <figure float="0" id="fig-jenkins-show-aggregate-tests">
        <title>Visualisation des résultats de tests agrégés</title>
        <mediaobject id="I_mediaobject10_d1e15890">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1054.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1054.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Pour que cela fonctionne correctement, vous devez vous assurer
      d'avoir configuré<indexterm id="I_indexterm10_d1e15897"
          significance="normal">
          <primary>fingerprints</primary>
        </indexterm> la création de fingerprint pour les fichiers binaires
      utilisés à chaque étape. Jenkins agrégera seulement les résultats de
      test avals de builds contenant un artefact avec le <indexterm
          class="endofrange" id="I_indexterm10_d1e15901" significance="normal"
          startref="ch10-agg1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e15903"
          significance="normal" startref="ch10-agg2">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e15905"
          significance="normal" startref="ch10-agg3">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e15907"
          significance="normal" startref="ch10-agg4">
          <primary></primary>
        </indexterm>même fingerprint.</para>
    </sect2>
    <sect2>
      <title>Pipelines de Build</title>
      <para>Le <indexterm class="startofrange" id="ch10-deploy1"
          significance="normal">
          <primary>pipelines de build</primary>
          <secondary>pipelines de déploiement</secondary>
        </indexterm><indexterm class="startofrange" id="ch10-deploy2"
          significance="normal">
          <primary>pipelines de déploiement</primary>
        </indexterm> dernier plugin que nous allons regarder dans cette
      section est le plugin Build Pipeline. Le plugin Build Pipelines emmène
      l'idée de la promotion de build encore plus loin, et vous aide à
      concevoir et superviser des pipelines de déploiement. Un pipeline de
      déploiement est une façon d'orchestrer vos builds au travers d'une série
      de passages garantissant la qualité, avec des approbations automatisées ou manuelles à
      chaque étape, culminant avec le déploiement en production.</para>
      <para>Le <indexterm id="I_indexterm10_d1e15926" significance="normal">
          <primary>plugin Build Pipeline</primary>
        </indexterm><indexterm id="I_indexterm10_d1e15929"
          significance="normal">
          <primary>plugins</primary>
          <secondary>Build Pipeline</secondary>
        </indexterm>plugin Build Pipeline fournit une autre façon de définir
      des tâches de build avals. Un pipeline de build, contrairement aux
      dépendances avals conventionnelles, est considéré comme un processus
      linéaire, une série de tâches de build exécutées en séquence.</para>
      <para>Pour utiliser ce plugin, commencez par configurer les tâches de
      build avals pour chaque tâche de build dans le pipeline, en utilisant le
      champ “Construire d'autres projets” comme vous le feriez habituellement. Le
      plugin Build Pipeline utilise les configurations de build amont ou aval
      standards, et pour les étapes automatiques c'est tout ce que vous avez à
      faire. Toutefois, le plugin Build Pipeline supporte aussi les étapes de
      build manuelles, où un utilisateur doit manuellement approuver l'étape
      suivante. Pour les étapes manuelles, vous devez aussi configurer les
      <command moreinfo="none">Post-build Actions</command> de votre tâche de
      build amont : cochez simplement la case “Build Pipeline Plugin -&gt;
      Spécifier Projet Aval”, sélectionnez l'étape suivante dans votre projet,
      et cochez l'option “Require manual build executor” (voir <xref
      linkend="fig-jenkins-build-pipeline-downstream" />).</para>
      <figure float="none" id="fig-jenkins-build-pipeline-downstream">
        <title>Configurer une étape manuelle dans le pipeline de build</title>
        <mediaobject id="I_mediaobject10_d1e15945">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1055.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1055.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Une fois que vous avez configuré votre processus de build à votre
      convenance, vous pouvez configurer la vue build pipeline. Vous pouvez
      créer cette vue comme n'importe quelle autre (voir <xref
      linkend="fig-jenkins-build-pipeline-view" />).</para>
      <figure float="none" id="fig-jenkins-build-pipeline-view">
        <title>Créer une vue Build Pipeline</title>
        <mediaobject id="I_mediaobject10_d1e15957">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1056.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1056.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Il y a une astuce à connaître lors de la configuration de la vue,
      cependant. Au moment de l'écriture de ces lignes, il n'y a pas d'option
      de menu ou de bouton vous permettant de configurer la vue directement.
      En fait, vous devez entrer l'URL manuellement. Heureusement, ce n'est
      pas difficile : ajoutez juste <filename
      moreinfo="none">/configure</filename> à la fin de l'URL lorsque vous
      affichez cette vue. par exemple, si vous avez appelé cette vue
      “phoenix-build-pipeline”, comme montré ici, l'URL pour configurer cette
      vue serait <filename
      moreinfo="none">http://my_jenkins_server/view/phoenix-build-pipeline</filename>.
      (voir <xref linkend="fig-jenkins-build-pipeline-configure" />).</para>
      <figure float="0" id="fig-jenkins-build-pipeline-configure">
        <title>Configurer une vue Build Pipeline</title>
        <mediaobject id="I_mediaobject10_d1e15975">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1057.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1057.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>La chose la plus importante à configurer dans cet écran est la
      tâche initiale. Ceci marque le point d'entrée de votre pipeline de
      build. Vous pouvez définir de multiples vues de pipeline de build,
      chacune avec une tâche initiale différente. Vous pouvez aussi configurer
      le nombre maximum de séquences de build à faire apparaître à la fois sur
      l'écran.</para>
      <para>Une fois que vous avez configuré le point de départ, vous pouvez
      retourner à la vue pour voir l'état courant de votre pipeline de build.
      Jenkins affiche les tâches de build successives horizontalement, en
      utilisant une couleur pour indiquer le résultat de chaque build (<xref
      linkend="fig-jenkins-build-pipeline" />). Il y a une colonne pour chaque
      tâche de build dans le pipeline. Dès lors que la tâche de build initiale
      démarre, une nouvelle ligne apparaît sur cette page. Alors que le build
      progresse parmi les tâches de build successives, Jenkins ajoute une
      boîte colorée dans les colonnes successives, indiquant le résultat de
      chaque étape. Vous pouvez cliquer sur la boîte pour descendre dans un
      résultat de build particulier pour plus de détails. Enfin, si une
      exécution manuelle est requise, un bouton sera affiché afin que
      l'utilisateur puisse déclencher la tâche.</para>
      <figure float="0" id="fig-jenkins-build-pipeline">
        <title>Un Pipeline de Build en action</title>
        <mediaobject id="I_mediaobject10_d1e15990">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_1058.pdf" format="PDF" />
          </imageobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_1058.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
      <?dbfo-need height=”1in”?>
      <para>Ce plugin est encore relativement nouveau, et ne s'intègre pas
      avec les autres plugins que nous avons vus ici. En particulier, il est
      vraiment conçu pour un pipeline de build linéaire, et ne s'en sort pas
      très bien avec des branches ou des tâches de build parallèles.
      Néanmoins, il donne une excellente vision globale d'un pipeline
      <indexterm class="endofrange" id="I_indexterm10_d1e15998"
          significance="normal" startref="ch10-deploy1">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e16000"
          significance="normal" startref="ch10-deploy2">
          <primary></primary>
        </indexterm><indexterm class="endofrange" id="I_indexterm10_d1e16002"
          significance="normal" startref="ch10-pipe">
          <primary></primary>
        </indexterm> de build.</para>
    </sect2>
  </sect1>
  <sect1 id="I_sect110_d1e16005">
    <title>Conclusion</title>
    <para>Les tâches de build d'Intégration Continue sont beaucoup plus que de
    simples exécutions planifiées de scripts de build. Dans ce chapitre, nous
    avons revu un certain nombre d'outils et de techniques vous permettant
    d'aller au delà de vos tâches de build typiques, en les combinant afin
    qu'elles travaillent ensemble comme partie d'un processus plus large. Nous
    avons à présent vu comment les tâches de build paramétrées et
    multiconfiguration ajoutent un élément de flexibilité aux tâches de build
    ordinaires en vous permettant d'exécuter la même tâche de build avec
    différents ensembles de paramètres. D'autres outils aident à coordonner et
    à orchestrer des groupes de tâches de build reliées. Les plugins Joins et
    Locks and Latches vous aident à coordonner des tâches de build s'exécutant
    en parallèle. Et les plugins Build Promotions et Build Pipelines, avec
    l'aide du plugin Copy Artifacts, rendent relativement facile la conception
    et la configuration de stratégies de promotion de build complexes pour vos
    projets.</para>
  </sect1>
</chapter>
