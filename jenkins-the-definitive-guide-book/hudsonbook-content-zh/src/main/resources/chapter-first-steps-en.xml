<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="chapter-first-steps">
  <title>Your first steps with Hudson</title>

  <sect1>
    <title>Introduction</title>

    <para>In this chapter, we are going to take a quick guided tour through
    some of Hudson's key features. You'll get to see first-hand just how easy
    it is to install Hudson and set up your first Hudson automated build job.
    We won't dwell on the details too much - there are more details to come in
    the following chapters, as well as a detailed chapter on Hudson
    Administration at the end of the book. This chapter is just an
    introduction. Still, by the end of the chapter, you will also be keeping
    tabs on test results, generating javadoc and publishing code coverage
    reports! We've got a lot of ground to cover, so let's get started!</para>
  </sect1>

  <sect1 id="sect-first-steps-environment">
    <title>Preparing your environment</title>

    <para>There are two ways you can tackle this chapter. You can read through
    it without touching a keyboard, just to get an overview of what Hudson is
    about. Or you can get your hands dirty, and follow along on your own
    machine.</para>

    <para>If you do want to follow along at home, you may need to set up some
    software on your local machine. Remember, the most basic function of any
    Continuous Integration tool is to monitor source code in a version control
    system and to fetch and build the latest version of your source code
    whenever any changes are committed. So you'll need a version control
    system. More precisely in our case, you'll need to set up a Subversion
    server on your local machine. You'll also need to download the pre-bundled
    Subversion repository from the book website. We'll explain how to set it
    all up in great detail further on.</para>

    <para>In this chapter, we'll be using Hudson to build a Java application
    using Maven. <indexterm>
        <primary>maven</primary>
      </indexterm>Maven is a widely-used build tool in the Java world, with
    many powerful features such as declarative dependency management,
    convention over configuration, and a large range of plugins. As we
    mentioned earlier, we'll also be using a Subversion repository to store
    the source code. For our build, we will also be using recent versions of
    the Java Development Kit (JDK) and Maven, but if you don't have these
    installed on your machine, don't fret! As we will see, Hudson will install
    them for you.</para>

    <sect2>
      <title>Installing Java</title>

      <para>The first thing you will need to install on your machine is Java.
      Hudson is a Java web application, so you will need at least the Java
      Runtime Environment, or JRE<indexterm>
          <primary>Java</primary>
        </indexterm><indexterm>
          <primary>Java</primary>

          <secondary>JRE</secondary>
        </indexterm> to run it. For the examples in this chapter, you will
      need a recent version of Java 6 (these examples were written with Java 6
      update 17, and the latest release at the time of writing was Java 6
      update 19). If you are not sure, you can check this from the command
      line (by opening a DOS console on Windows), and running '<command>java
      -version</command>'. If Java is installed on your machine should get
      something like this:<screen>$ <command>java -version</command>
java version "1.6.0_17"
Java(TM) SE Runtime Environment (build 1.6.0_17-b04-248-10M3025)
Java HotSpot(TM) 64-Bit Server VM (build 14.3-b01-101, mixed mode)</screen></para>

      <para>If you don't have a version already installed, or if your version
      is an older one, download and install the latest JRE installer from the
      Java web site (<ulink
      url="http://java.sun.com/javase/downloads/index.jsp"></ulink>) (see
      <xref linkend="fig-installing-java" />).</para>

      <figure id="fig-installing-java">
        <title>Installing Java</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center" fileref="figs/web/java-install.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>

    <sect2>
      <title>Installing a local Subversion server</title>

      <para>The examples in this chapter use Subversion, so to run them on
      your own machine, you will also need to install and run a local
      Subversion server on your workstation. If this sounds a little daunting,
      don't worry - it's actually pretty straightforward, and we'll step you
      through the process. Otherwise, you can follow along without running the
      examples and still get a good feel for what Hudson can do.</para>

      <para>Subversion comes pre-installed on Mac OS X and many flavors of
      Linux. Just make sure you have the Subversion server tools
      (<command>svnserve</command> in particular) installed. You can check
      this by running the <indexterm>
          <primary>Subversion</primary>

          <secondary>svnserve</secondary>
        </indexterm><command>svnserve</command> command from the command line
      or in a DOS window as shown here:<screen>$ <command>svnserve --version</command>
svnserve, version 1.6.2 (r37639)
   compiled May 14 2009, 14:34:54

Copyright (C) 2000-2009 CollabNet.
Subversion is open source software, see http://subversion.tigris.org/
This product includes software developed by CollabNet (http://www.Collab.Net/).

The following repository back-end (FS) modules are available:

* fs_base : Module for working with a Berkeley DB repository.
* fs_fs : Module for working with a plain file (FSFS) repository.

Cyrus SASL authentication is available.</screen></para>

      <para>If you get an error, you probably haven't got the Subversion
      server software installed on your machine. You will need Subversion 1.6
      or higher to work with the sample repositories, so if you have an older
      version of Subversion installed, you will also need to upgrade.</para>

      <para>You can find the Subversion installation packages, or installation
      instructions, for your operation system from the Subversion website
      (<ulink url="http://subversion.apache.org"></ulink>). If you are
      installing Subversion on Windows, make sure you only install the basic
      command-line Subversion tools (<command>svn</command> and
      <command>svnserve</command> in particular). Some of the Windows
      installation packages, such as those from Collabnet and VisualSVN, will
      install Subversion as a service on your workstation and set up an empty
      repository for you. This is great if you are installing a Subversion
      server, and if you are familiar with Subversion administration, but for
      our purposes it is overkill, and will interfere with the instructions we
      provide.</para>

      <para>A better choice in this regard is the <indexterm>
          <primary>Subversion</primary>

          <secondary>SlikSVN</secondary>
        </indexterm>SlikSVN installer (<ulink
      url="http://www.sliksvn.com/en/download"></ulink>), which will only
      install the bare-bones Subversion command-line tools, which suits us
      just fine. However, be sure to choose the 'Complete' setup type (see
      <xref linkend="fig-sliksvn-install" />), as this is the only one that
      includes the <command>svnserve</command> tool.</para>

      <figure id="fig-sliksvn-install">
        <title>Installing Slik Subversion</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center" fileref="figs/web/sliksvn-install.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Once you have installed Subversion, you should check that it is
      working properly. Open a command prompt and run <command>svnserve
      -version</command>. You should now get something like this: <screen>C:\Documents and Settings\Owner&gt;<command>svnserve --version</command>
svnserve, version 1.6.9 (SlikSvn:tag/1.6.9@902044) WIN32
   compiled Jan 22 2010, 10:39:27

Copyright (C) 2000-2009 CollabNet.
Subversion is open source software, see http://subversion.tigris.org/
This product includes software developed by CollabNet (http://www.Collab.Net/).

The following repository back-end (FS) modules are available:

* fs_base : Module for working with a Berkeley DB repository.
* fs_fs : Module for working with a plain file (FSFS) repository.

Cyrus SASL authentication is available.</screen></para>

      <para>With Subversion now installed, we can proceed to set up the sample
      repository containing the project we will be building with
      Hudson.</para>
    </sect2>

    <sect2>
      <title>Setting up the sample Subversion repository</title>

      <para>All of the <indexterm>
          <primary>Sample projects</primary>
        </indexterm>sample projects used in this book are available online.
      You can download the Subversion repository used for this chapter from
      the book web site, which you can find at <ulink
      url="http://www.continuous-integration-with-hudson.org"></ulink>. Go to
      this page now and download the book-examples zip file. When you unzip
      this file, you should see a sub-folder for each chapter of the book (see
      <xref linkend="fig-first-steps-examples" />).</para>

      <figure id="fig-first-steps-examples">
        <title>The Book examples folder on a Windows machine</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/first-steps-examples.png "
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>A Subversion repository is a simple directory structure that can
      be used on any operating system. In our case, the repository is stored
      in a directory called <indexterm>
          <primary>Subversion</primary>

          <secondary>svn-repos directory</secondary>
        </indexterm><filename>svn-repos</filename>, which you will find in the
      <filename>chapter-first-steps</filename> directory of the book
      resources. You don't have to worry about the details, though. To start
      up the Subversion server on your machine, just go to the
      <filename>chapter-first-steps</filename> directory and run the <ulink
      url="start-svn.bat"></ulink> script (for Windows) or the <ulink
      url="start-svn.sh"></ulink> script (on Linux, Mac OS, and so
      forth).</para>

      <para>If you are more experienced with Subversion, you might like to
      start the server manually yourself. In this case, open up a command-line
      prompt in the <filename>chapter-first-steps</filename> directory and run
      the following command:<screen>$<command> svnserve -d -r svn-repos</command></screen></para>

      <para>In both cases, you will end up with a Subversion server running on
      your machine. In a Linux or Mac OS X environment, the process will run
      as a daemon in the background. On Windows, it will just run in the
      command prompt until you stop it manually using Control-C (see <xref
      linkend="fig-running-svnserve" />). If your are running Subversion on
      Windows, make sure you don't shut this window!</para>

      <figure id="fig-running-svnserve">
        <title>Running the svnserve Subversion server in Windows</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center" fileref="figs/web/svnserve-running.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Finally, just to make sure everything is working, open another
      command prompt and run the <command>svn list</command> command. This
      will display a listing of the top-level directory in our Subversion
      repository, which should look something like this:<screen>$ <command>svn list svn://localhost/gameoflife/trunk</command>
.classpath
.project
.settings/
pom.xml
src/</screen></para>

      <para>This is all you really need to follow along for the rest of the
      chapter. So now, let's take Hudson for a spin.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Starting up Hudson</title>

    <para><indexterm>
        <primary>Hudson</primary>

        <secondary>Staring using Java Web Start</secondary>
      </indexterm>There are several ways to run Hudson on your machine. One of
    the easiest way to run Hudson for the first time is to use Java Web Start.
    Java Web Start is a technology that lets you start up a Java application
    on your local machine via a URL on a web page - it comes bundled with the
    Java JRE. In our case, this will start a Hudson server running on your
    machine, and let you experiment with it as if it were installed locally.
    All you need for this to work is a recent (Java 6 or later) version of the
    Java Runtime Environment (JRE), which we installed in the previous
    section.</para>

    <para>For convenience, there is a link to the Hudson Java Web Start
    instance on the book resources page (at <ulink
    url="http://www.continuous-integration-with-hudson.org"></ulink>). Here
    you will find a large orange 'Launch' button in the "Book Resources"
    section (see <xref linkend="fig-hudson-webstart-page" />). You can also
    find this link on the 'Meet Hudson' page on the Hudson website (<ulink
    url="http://wiki.hudson-ci.org/display/HUDSON/Meet+Hudson"></ulink>),
    where, if you scroll down far enough, you should find a 'Test Drive'
    section with an identical 'Launch' button'.</para>

    <figure id="fig-hudson-webstart-page">
      <title>Running Hudson using Java Web Start from the Book web
      site</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center" fileref="figs/web/hudson-webstart.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Java Web Start seems to work best on Firefox. When you click on the
    'Launch' button on either of these sites in Firefox, the browser will ask
    if you want to open a file called 'hudson.jnlp' using Java Web Start.
    Click on OK - this will download Hudson and start it up on your machine
    (see <xref linkend="fig-first-steps-downloading-hudson" />).</para>

    <para>In other browsers, clicking on this button may simply download the
    JNLP file. In Internet Explorer, you may even need to right click on the
    link and select 'Save Target As' to save the JNLP file, and then run run
    it from Windows Explorer. However, in both of these cases, when you open
    the JNLP file, Java Web Start will download and start Hudson.</para>

    <figure id="fig-first-steps-downloading-hudson">
      <title>Java Web Start will download and run the latest version of
      Hudson</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/first-steps-downloading-hudson.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Java Web Start will only need to download a particular version of
    Hudson once. From then on, when you click on the 'Launch' button again,
    Java Web Start will use the copy of Hudson it has already downloaded (that
    is, until the next version comes out). Ignore any messages your operating
    system or anti-virus software may bring up - it is perfectly safe to run
    Hudson on your local machine.</para>

    <para>Once it has finished downloading, it will start up Hudson on your
    machine. You will be able to see it running in a small window called
    "Hudson Console" (see <xref linkend="fig-first-steps-console" />). To stop
    Hudson at any time, just close this window.</para>

    <figure id="fig-first-steps-console">
      <title>Java Web Start will download and run the latest version of
      Hudson</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center" fileref="figs/web/first-steps-console.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para><indexterm>
        <primary>Hudson</primary>

        <secondary>Starting from the command line</secondary>
      </indexterm>If you are an experienced Java user versed in the ways of
    WAR files, you may prefer to simply download the latest version of Hudson
    and run it from the command line. Hudson comes in the form of an
    executable WAR file - you can download the most recent version from the
    Hudson website home page (<ulink url="http://hudson-ci.org"></ulink>). For
    convenience, there is also a link to the latest version of Hudson in the
    Resources section of the book website (at <ulink
    url="http://www.continuous-integration-with-hudson.org"></ulink>).</para>

    <para>Once downloaded, you can start Hudson from the command line as shown
    here:</para>

    <para><screen>$ <command>java -jar hudson.war</command></screen></para>

    <para>Whether you have started Hudson using Java Web Start or from the
    command line, Hudson should now be running on your local machine. By
    default, Hudson will be running on port 8080, so you can access Hudson in
    your web browser on <ulink url="http://localhost:8080"></ulink>.</para>

    <para>Alternatively, if you are familiar with Java application servers
    such as Tomcat, you can simply deploy the Hudson war file to your
    application server - with Tomcat, for example, you could simply place the
    <filename>hudson.war</filename> file in Tomcat's
    <filename>webapps</filename> directory. If you are running Hudson on an
    application server, the URL that you use to access Hudson will be slightly
    different. On a default Tomcat installation, for example, you can access
    Hudson in your web browser on <ulink
    url="http://localhost:8080/hudson"></ulink>.</para>

    <para>When you open Hudson in your browser, you should see a screen like
    the one shown in <xref linkend="fig-hudson-start" os="" />. You are now
    ready to take your first steps with Hudson!</para>

    <figure id="fig-hudson-start">
      <title>The Hudson start page</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center" fileref="figs/web/hudson-start.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>
  </sect1>

  <sect1>
    <title>Configuring the tools</title>

    <para>Before we get started, we do need to do a little configuration. More
    precisely, we need to tell Hudson about the build tools and JDK versions
    we will be using for our builds.</para>

    <para>Click on the <indexterm>
        <primary>Hudson</primary>

        <secondary>Manage Hudson screen</secondary>
      </indexterm>'Manage Hudson' link on the home page (see <xref
    linkend="fig-hudson-start" os="" />). This will take you to the 'Manage
    Hudson' page, the central one-stop-shop for all your Hudson configuration.
    From this screen, you can configure your Hudson server, install and
    upgrade plugins, keep track of system load, manage distributed build
    servers, and more! For now, however, we'll keep it simple. Just click on
    the 'Configuring System' link at the top of the list (see <xref
    linkend="fig-hudson-manage" />).</para>

    <figure id="fig-hudson-manage">
      <title>The Manage Hudson screen</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center" fileref="figs/web/hudson-manage.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>This will take you to Hudson's main configuration screen (see <xref
    linkend="fig-hudson-configure" />). From here you can configure everything
    from security configuration and build tools to email servers, version
    control systems and integration with third-party software. The screen
    contains a lot of information, but most of the fields contain sensible
    default values, so you can safely ignore them for now.</para>

    <figure id="fig-hudson-configure">
      <title>The Configure Hudson screen</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center" fileref="figs/web/hudson-configure.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>For now, you will just need to configure the tools required to build
    our sample project. The application we will be building is a Java
    application, built using Maven. So in this case, all we need to do is to
    set up a recent JDK and Maven installation.</para>

    <para>However before we start, take a look at the little blue question
    mark icons lined to the right of the screen. These are Hudson's contextual
    help buttons. If you are curious about a particular field, click on the
    help icon next to it and Hudson will display a very detailed description
    about what it is and how it works.</para>

    <para><indexterm>
        <primary>Maven</primary>
      </indexterm>Let's configure Maven first. Hudson provides great
    out-of-the-box support for Maven. Scroll down until you reach the 'Maven'
    section in the 'Configure System' screen (see <xref lang=""
    linkend="fig-hudson-maven" />).</para>

    <para>Hudson provides several options when it comes to configuring Maven.
    If you already have Maven installed on your machine, you can simply
    provide the path in the MAVEN_HOME field. Alternatively, you can install a
    Maven distribution by extracting a zip file located in a shared directory,
    or execute a home-rolled installation script. Or you can let Hudson do all
    the hard work and download Maven for you. To choose this option, just tick
    the 'Install automatically' check box. Hudson will download and install
    Maven from the Apache web site the first time a build job needs it. Just
    choose the Maven version you want to install and Hudson will do the rest.
    You will also need to give a name for your Maven version (imaginatively
    called "Maven 2.2.1" in the example), so that you can refer to it in your
    build jobs.</para>

    <para>For this to work, you need to have an Internet connection. If you
    are behind a proxy, you'll need to provide your proxy information - we
    discuss how to set this up in <xref
    linkend="sect-configuration-proxies" />.</para>

    <figure id="fig-hudson-maven">
      <title>Configuring a Maven installation</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-configure-maven.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>One of the nice things about the Hudson Maven installation process
    is how well it works with remote build agents. Later on in the book, we'll
    see how Hudson can also run builds on remote build servers. You can define
    a standard way of installing Maven for all of your build servers
    (downloading from the internet, unzipping a distribution bundle on a
    shared server,...) - all of these options will work when you add a new
    remote build agent or set up a new build server using this Hudson
    configuration.</para>

    <para><indexterm>
        <primary>JDK</primary>
      </indexterm>Once you have configured your Maven installation, you will
    also need to configure a JDK installation (see <xref
    linkend="fig-hudson-jdk" />). Again, if you have a Java JDK (as opposed to
    a Java Runtime Environment - the JDK contains extra development tools such
    as the Java compiler) already installed on your workstation, you can
    simply provide the path to your JDK in the JAVA_HOME field. Otherwise, you
    can ask Hudson to download the JDK from the <ulink
    url="http://java.sun.com"></ulink> website the first time a build job
    requires it. This is similar to the automatic Maven installation feature -
    just pick the JDK version you need and Hudson will take care of all the
    logistics. However, for licensing reasons, you will also need to tick a
    check box to indicate that you agree with the Java SDK License
    Agreement.</para>

    <figure id="fig-hudson-jdk">
      <title>Configuring a JDK installation</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-configure-jdk.png" width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The last thing you would typically set up is notification. When a
    Hudson build breaks, and when it works again, it can send out email
    messages to the team to spread the word. Using plugins, you can also get
    it to send instant messages or SMS messages, post entries on Twitter, or
    get people notified in a few other ways. It all depends on what works best
    for your organizational culture. However, to keep things simple, we're not
    going to worry about notifications just yet.</para>

    <para>That is all we need to configure at this stage. Go to the bottom of
    the screen and click on the 'Save' button. You are now ready to set up
    your first Hudson build job!</para>
  </sect1>

  <sect1>
    <title>Your first Hudson build job</title>

    <para>Build jobs are at the heart of the Hudson build process. Simply put,
    you can think of a Hudson build job as a particular task or step in your
    build process. This may involve simply compiling your source code and
    running your unit tests. Or you might want a build job to do other related
    tasks, such as running your integration tests, measuring code coverage or
    code quality metrics, generating technical documentation, or even
    deploying your application to a web server. A real project usually
    requires many separate but related build jobs.</para>

    <para>Our sample application is a simple Java implementation of John
    Conway's <indexterm>
        <primary>Game Of Life</primary>
      </indexterm>"Game Of Life"<footnote id="footnote-game-of-life">
        <para>See http://en.wikipedia.org/wiki/Conway's_Game_of_Life</para>
      </footnote>. The Game of Life is a mathematical game which takes place
    on a two dimensional grid of cells, which we will refer to as the
    Universe. Each cell can be either alive or dead. Cells interact with their
    direct neighbours to determine whether they will live or die in the next
    generation of cells. For each new generation of cells, the following rules
    are applied:</para>

    <orderedlist>
      <listitem>
        <para>Any live cell with fewer than two live neighbours dies of
        underpopulation.</para>
      </listitem>

      <listitem>
        <para>Any live cell with more than three live neighbours dies of
        overcrowding.</para>
      </listitem>

      <listitem>
        <para>Any live cell with two or three live neighbours lives on to the
        next generation.</para>
      </listitem>

      <listitem>
        <para>Any dead cell with exactly three live neighbours becomes a live
        cell.</para>
      </listitem>
    </orderedlist>

    <para>Our application is a Java module, built using Maven, that implements
    the core business logic of the Game of Life. We'll worry about the user
    interfaces later on. For now, let's see how we can automate this build in
    Hudson. If you are not familiar with Maven, or prefer Ant or another build
    framework - don't worry! The examples don't require much knowledge of
    Maven, and we'll be looking at plenty of examples of using other build
    tools later on in the book.</para>

    <para>For our first build job, we will keep it simple: we are just going
    to compile and test our sample application. Click on the 'New Job' link.
    You should get to a screen similar to <xref
    linkend="fig-first-build-job" />. Hudson supports several different types
    of build job. The two most commonly-used are the free-style builds and the
    Maven 2 builds. The free-style projects allow you to configure just about
    any sort of build job: they are highly flexible and very configurable. The
    Maven 2 builds understand the Maven project structure, and can use this to
    let you set up Maven build jobs with less effort and a few extra features.
    There are also plugins that provide support for other types of build jobs.
    Nevertheless, although our project does use Maven, we are going to use a
    free-style build job, just to keep things simple and general to start
    with. So choose 'Build a free-style software project', as shown in <xref
    linkend="fig-first-build-job" />.</para>

    <para>You'll also need to give your build job a sensible name. In this
    case, call it 'gameoflife-default', as it will be the default CI build for
    our Game Of Life project.</para>

    <para><figure id="fig-first-build-job">
        <title>Setting up your first build job in Hudson</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center" fileref="figs/web/hudson-new-job.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>Once you click on OK, Hudson will display the project configuration
    screen (see <xref linkend="fig-new-job-svn" />).</para>

    <para>In a nutshell, Hudson works by checking out the source code of your
    project and building it in it's own workspace. So the next thing you need
    to do is to tell Hudson where it can find the source code for your
    project. You do this in the 'Source Code Managment' section. Hudson
    provides support for CVS and Subversion out of the box, and many others
    such as Git, Mercurial, ClearCase, Perforce and many more via
    plugins.</para>

    <para><indexterm>
        <primary>SCM</primary>

        <secondary>Configuring in Freestyle build jobs</secondary>
      </indexterm>For this project, we will be getting the source code from
    the local Subversion repository we set up earlier (so make sure you have
    this Subversion repository up and running, as we described in <xref
    linkend="sect-first-steps-environment" />). On the Hudson screen, choose
    'Subversion' and enter <ulink
    url="svn://localhost/gameoflife/trunk"></ulink> as the Repository URL (see
    <xref linkend="fig-new-job-svn" />). Also, place a dot (".") in the 'Local
    Directory Module' field. This makes Hudson check out the source code
    directly into the build job's workspace. If you don't do this, Subversion
    will check the source code out to a subdirectory called
    <filename>trunk</filename>. Using the build job's workspace makes some of
    the other options a little simpler to configure. You can leave all of the
    other options up until here with their default values.</para>

    <figure id="fig-new-job-svn">
      <title>Telling Hudson where to find the source code</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-freestyle-svn.png" width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Once we have told Hudson where to find the source code for our
    application, we need to tell it how often it should check for updates. We
    want Hudson to monitor the repository and start a build whenever any
    changes have been committed. This is a common way to set up a build job in
    a Continuous Integration context, as it provides fast feedback if the
    build fails. Other approaches include building on regular intervals (for
    example, once a day), requiring a user to kick of the build manually, or
    even triggering a build remotely using a "post-commit" hook in your
    SCM.</para>

    <para><indexterm>
        <primary>Build Triggers</primary>

        <secondary>Configuring in Freestyle build jobs</secondary>
      </indexterm>We configure all of this in the 'Build Triggers' section
    (see <xref linkend="fig-new-job-triggers" />). Pick the 'Poll SCM' option
    and enter '* * * * *' (that's five asterisks) in the Schedule box. Hudson
    schedules are configured using the <command>cron</command> syntax,
    well-known in the Unix world. The <command>cron</command> syntax consists
    of five fields separated by white space, indicating respectivly the minute
    (0-59), hour (0-23), day of the month (1-31), month (1-12) and the day of
    the week (0-7, with 0 and 7 being Sunday). The star is a wildcard
    character which accepts any valid value for that field. So five stars
    basically means "every minute of every hour of every day". You can also
    provide ranges of values: "* 9-17 * * *" would mean "every minute of every
    day, between 9am and 5pm". You can also space out the schedule using
    intervals: "*/5 * * * *" means "every 5 minutes, for example. Finally,
    there are some other convenient short-hands, such as "@daily" and
    "@hourly".</para>

    <para>Don't worry if your Unix skills are a little rusty - if you click on
    the blue question mark icon on the side of the schedule box, Hudson will
    bring up a very complete refresher.</para>

    <figure id="fig-new-job-triggers">
      <title>Scheduling the build jobs</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-triggers.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The next step is to configure the actual build itself. In a
    free-style build job, you can break down your build job into a number of
    build steps. This makes it easier to organize builds in clean, separate
    stages. For example, a build might run a suite of functional tests in one
    step, and then tag the build in a second step if all of the functional
    tests succeed. In technical terms, a build step might involve invoking an
    Ant task or a Maven target, or running a shell script. There are also
    Hudson plugins that let you use additional types of build steps: Gant,
    Grails, Gradle, Rake, Ruby, MSBuild and many other build tools are all
    supported.</para>

    <para><indexterm>
        <primary>Maven</primary>

        <secondary>Configuring in Freestyle build jobs</secondary>
      </indexterm>For now, we just want to run a simple Maven build. Scroll
    down to the 'Build' section and click on the 'Add Build Step' and choose
    'Invoke top-level Maven targets' (see <xref
    linkend="fig-new-job-build-step" />). Then enter 'clean package' in the
    Goals field. If you are not familiar with Maven, this will delete any
    previous build artifacts, compile our code, run our unit tests and
    generates a JAR file.</para>

    <figure id="fig-new-job-build-step">
      <title>Adding a build step</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-build-step.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>By default, this build job will fail if the code does not compile or
    if any of the unit tests fail. That's the most fundamental thing that
    you'd expect of any build server. But Hudson also does a great job of
    helping you display your test results and test result trends.</para>

    <para>The defacto standard for test reporting in the Java world is an XML
    format used by JUnit. This format is also used by many other Java testing
    tools, such as TestNG, Spock and Easyb. Hudson understands this format, so
    if your build produces JUnit XML test results, Hudson can generate nice
    graphical test reports and statistics on test results over time, and also
    let you view the details of any test failures. Hudson also keeps track of
    how long your tests take to run, both globally, and per test - this can
    come in handy if you need to track down performance issues.</para>

    <para>So the next thing we need to do is to get Hudson to keep tabs on our
    unit tests.</para>

    <para><indexterm>
        <primary>JUnit reports</primary>

        <secondary>Configuring in Freestyle build jobs</secondary>
      </indexterm>Go to the 'Post-build Actions' section (see <xref
    linkend="fig-new-job-test-reports" />) and tick 'Publish JUnit test result
    report' checkbox. When Maven runs unit tests in a project, it
    automatically generates the XML test reports in a directory called
    <filename>surefire-reports</filename> in the <filename>target</filename>
    directory. So enter "**/target/surefire-reports/*.xml" in the 'Test report
    XMLs' field. The two asterisks at the start of the path ('**') are a best
    practice to make the configuration a bit more robust: they allow Hudson to
    find the target directory no matter how we have configured Subversion to
    check out the source code.</para>

    <para>Another thing you often want to do is to archive your build results.
    Hudson can store a copy of the binary artifacts generated by your build,
    allowing you to download the binaries produced by a build directly from
    the build results page. It will also post the latest binary artifacts on
    the project home page, which is a convenient way to distribute the latest
    and greatest version of your application. You can activate this option by
    ticking the 'Archive the artifacts' checkbox and indicating which binary
    artifacts you want Hudson to archive. In <xref
    linkend="fig-new-job-test-reports" />, for example, we have configured
    Hudson to store all of the JAR files generated by this build job.</para>

    <figure id="fig-new-job-test-reports">
      <title>Configuring JUnit test reports and artifact archiving</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-tests-no-email.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Now we're done - just click on the Save button at the bottom of the
    screen. Our build job should now be ready to run. So let's see it in
    action!</para>
  </sect1>

  <sect1>
    <title>Our first build job in action</title>

    <para>Once you save your new build job, Hudson will display the home page
    for this job (see <xref linkend="fig-new-job-running" />). This is where
    Hudson displays details about the latest build results and the build
    history.</para>

    <para>If you wait a minute or so, the build should kick off automatically
    - you can see the stripy progress bar in the 'Build History' section in
    the bottom left hand corner of <xref linkend="fig-new-job-running" />. Or,
    if you are impatient, you can also trigger the build manually using the
    'Build Now' button.</para>

    <figure id="fig-new-job-running">
      <title>Your first build job running</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-running.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The build will also now figure proudly on your Hudson server's home
    page (see <xref linkend="fig-hudson-dashboard" />). This page shows a
    summary of all of your build jobs, including the current build status and
    general state of heath of each of your builds. It tells you when each
    build ran successfully for the last time, and when it last failed, and
    also the result of the last build.</para>

    <para>Once of Hudson's specialities is the way it lets you get an idea of
    build behaviour over time. For example, Hudson uses a weather metaphor to
    help give you an idea of the stability of your builds. Essentially, the
    more your builds fail, the worse the weather gets. This helps you get an
    idea of whether a particular broken build is an isolated event, or if the
    build is breaking on a regular basis, in which case it might need some
    special attention.</para>

    <para>You can also manually trigger a build job here, using the build
    schedule button (that's the one that looks a bit like a green play button
    on top of a clock).</para>

    <figure id="fig-hudson-dashboard">
      <title>The Hudson dashboard</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-home-job-list.png" width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>When the build finishes, the ball in the Build History box becomes
    solid blue. This means the build was a success. Build failures are
    generally indicated by a red ball. For some types of project, you can also
    distinguish between a build error (such as a compiler error), indicated by
    a red ball, and other sorts of build failures, such as unit test failures
    or insufficient code coverage, which are indicated by a yellow ball. There
    are also some other details about the latest test results, when the last
    build was run, and so on. But before we look at the details, let's get
    back to the core business model of a Continuous Integration server -
    kicking off builds when someone changes the code!</para>

    <para>We are going to commit a code change to Subversion and see what
    happens. First, you will need to check out a copy of the source code from
    the Subversion repository we set up. You can do this is from the command
    line as shown here:<screen>$ <command>svn co svn://localhost/gameoflife/trunk gameoflife</command>
...
A    gameoflife/src
A    gameoflife/src/test
A    gameoflife/src/test/java
A    gameoflife/src/test/java/com
A    gameoflife/src/test/java/com/ciwithhudson
A    gameoflife/src/test/java/com/ciwithhudson/gameoflife
A    gameoflife/src/test/java/com/ciwithhudson/gameoflife/domain
A    gameoflife/src/test/java/com/ciwithhudson/gameoflife/domain/CellTest.java
A    gameoflife/src/test/java/com/ciwithhudson/gameoflife/domain/UniverseTest.java
A    gameoflife/src/test/java/com/ciwithhudson/gameoflife/domain/GridTest.java
A    gameoflife/src/test/resources
A    gameoflife/src/main
A    gameoflife/src/main/java
A    gameoflife/src/main/java/com
A    gameoflife/src/main/java/com/ciwithhudson
A    gameoflife/src/main/java/com/ciwithhudson/gameoflife
A    gameoflife/src/main/java/com/ciwithhudson/gameoflife/domain
A    gameoflife/src/main/java/com/ciwithhudson/gameoflife/domain/Cell.java
A    gameoflife/src/main/java/com/ciwithhudson/gameoflife/domain/Universe.java
A    gameoflife/src/main/java/com/ciwithhudson/gameoflife/domain/Grid.java
A    gameoflife/src/main/java/com/ciwithhudson/gameoflife/domain/LivingCell.java
A    gameoflife/src/main/java/com/ciwithhudson/gameoflife/domain/DeadCell.java
A    gameoflife/src/main/resources
A    gameoflife/pom.xml
...
Checked out revision 6.</screen></para>

    <para>This will download the source code for our demo project into the
    <filename>gameoflife</filename> directory. Now, if we make any changes, we
    will be able to push them onto the Subversion repository and see if Hudson
    can pick them up.</para>

    <para>So let's make a change. The idea is to introduce a code change that
    will cause the unit tests to fail. If your Java is a bit rusty, don't
    worry, you won't need to know any Java to be able to break the build -
    just follow the instructions!</para>

    <para>Now in normal development, you would first modify the unit test that
    describes this behaviour. Then you would verify that the test fails with
    the existing code, and implement the code to ensure that the test passes.
    <emphasis>Then</emphasis> you would commit your changes to Subversion,
    allowing Hudson to build them. However this would be a poor demonstration
    of how Hudson handles unit test failures. So in this example, we will,
    against all best practices, simply modify the application code
    directly.</para>

    <para>First of all, open the <filename>LivingCell.java</filename> file,
    which you will find in the
    <filename>gameoflife-core/src/main/java/com/ciwithhudson/gameoflide/domain</filename>
    directory. Open this file in your favorite text editor. You should see
    something like this:</para>

    <programlisting>package com.ciwithhudson.gameoflife.domain;

public class LivingCell extends Cell {

    public static final char SYMBOL = '+';
    
    @Override
    public Boolean isAlive() {
        return true;
    }

    @Override
    public Cell nextGeneration(int neighbourCount) {
        if (neighbourCount &gt;= 2 &amp;&amp; neighbourCount &lt;= 3) {
            return new LivingCell();
        } else {
            return new DeadCell();
        }
    }

    @Override
    public String toString() {
        return Character.toString(SYMBOL);
    }
    
}</programlisting>

    <para>The application can print the state of the grid as a text array.
    Currently, the application prints our live cells as a plus character
    ('+'), and dead cells appear as a minus character ('-'). So a five-by-five
    grid containing a single living cell in the center would look like
    this:<screen>-----
--+--
-----</screen> Now users have asked the application - they want stars ('*')
    instead of pluses! So we are going to make a slight change to the
    <code>LivingCell</code> class method, and rewrite it as follows (the
    modified line is in <command>bold</command>):</para>

    <programlisting>public class LivingCell extends Cell {

    <command>public static final char SYMBOL = '*';</command>
    
    @Override
    public Boolean isAlive() {
        return true;
    }

    @Override
    public Cell nextGeneration(int neighbourCount) {
        if (neighbourCount &gt;= 2 &amp;&amp; neighbourCount &lt;= 3) {
            return new LivingCell();
        } else {
            return new DeadCell();
        }
    }

    @Override
    public String toString() {
        return Character.toString(SYMBOL);
    }
    
}</programlisting>

    <para>Save this change, and then commit them to the Subversion repository
    by running "<command>svn commit</command>" from the
    <filename>babble</filename> directory: <screen>$ <command>svn commit -m "Live cells should display as stars and not pluses"</command>
Sending        src/main/java/com/ciwithhudson/gameoflife/domain/LivingCell.java
Transmitting file data .
Committed revision 7.</screen></para>

    <para><indexterm>
        <primary>Build failures</primary>
      </indexterm>Now go back to the Hudson web page. After a minute or so, a
    new build should kick off, and fail. In fact, there are several other
    places which are affected by this change, and the regression tests related
    to these features are now failing. On the build job home page, you will
    see a second build in the build history with an ominous red ball (see
    <xref linkend="fig-new-job-failed" />) - this tells you that the latest
    build has failed.</para>

    <para>You might also notice some clouds next to the Build History title -
    this is the same "weather" icon that we saw on the home page, and serves
    the same purpose - to give you a general idea of how stable your build is
    over time.</para>

    <figure id="fig-new-job-failed">
      <title>A failed build</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-failed.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>If you click on the new build history entry, Hudson will give you
    some more details about what went wrong (see <xref
    linkend="fig-new-job-failure-details" />). Hudson tells us that there were
    11 new test failures in this build, something which can be seen at a
    glance in the <indexterm>
        <primary>Test Result Trend</primary>
      </indexterm>Test Result Trend graph - red indicates test failures. You
    can even see which tests are failing, and how long they have been
    broken.</para>

    <figure id="fig-new-job-failure-details">
      <title>The list of all the broken tests</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-failure-details.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>If you want to know exactly what went wrong, that's easy enough to
    figure out as well. If you click on the failed test classes, Hudson brings
    up the actual details of the test failures (see <xref
    linkend="fig-hudson-new-job-test-failure-details" />), which is a great
    help when it comes to reproducing and fixing the issue.</para>

    <figure id="fig-hudson-new-job-test-failure-details">
      <title>Details about a failed test</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-test-failure-details.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Hudson displays a host of information about the failed test in a
    very readable form, including the error message the test produced, the
    stack trace, how long the test has been broken, and how long it took to
    run. Often, this in itself is enough to put a developer on the right track
    towards fixing the issue.</para>

    <para>Now let's fix the build. To make things simple, we'll just back out
    our changes and recommit the code in it's original state (the end users
    just changed their mind about the asterisks, anyway). So just undo the
    changes you made to the <filename>LivingCell</filename> class (again, the
    changes are highlighted in <command>bold</command>):</para>

    <programlisting>public class LivingCell extends Cell {

    <command>public static final char SYMBOL = '+';</command>
    
    @Override
    public Boolean isAlive() {
        return true;
    }

    @Override
    public Cell nextGeneration(int neighbourCount) {
        if (neighbourCount &gt;= 2 &amp;&amp; neighbourCount &lt;= 3) {
            return new LivingCell();
        } else {
            return new DeadCell();
        }
    }

    @Override
    public String toString() {
        return Character.toString(SYMBOL);
    }
    
}</programlisting>

    <para>When you've done this, commit your changes again:<screen>$ <command>svn commit -m "Fixed broken unit tests"</command>
Sending        src/main/java/com/ciwithhudson/gameoflife/domain/LivingCell.java
Transmitting file data .
Committed revision 8.</screen>Once you've committed these changes, Hudson
    should pick them up and kick off a build. Once this is done, you will be
    able to see the fruit of your work on the build job home page (see <xref
    linkend="fig-new-job-fixed-build" />) - the build status is blue again and
    all is well. Also notice the way we are building up a trend graph showing
    the number of succeeding unit tests over time - this sort of report really
    is one of Hudson's strong points.</para>

    <figure id="fig-new-job-fixed-build">
      <title>Now the build is back to normal</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-fixed.png" width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>
  </sect1>

  <sect1>
    <title>More reporting - displaying Javadocs</title>

    <para><indexterm>
        <primary>Javadocs</primary>
      </indexterm>For many Java projects, Javadoc comments are an important
    source of low-level technical documentation. There are even tools, such as
    UmlGraph, that let you produce Javadoc with embedded UML diagrams to give
    you a better picture of how the classes fit together in the application.
    This sort of technical documentation has the advantage of being cheap to
    produce, accurate and always up-to-date.</para>

    <para>Hudson can integrate Javadoc API documentation directly into the
    Hudson web site. This way, everyone can find the latest Javadoc easily, in
    a well known place. Often, this sort of task is performed in a separate
    build job, but for simplicity we are going to add another build step to
    the gameoflife-default build job to generate and display Javadoc
    documention for the Game Of Life API.</para>

    <para>Start off by going into the 'gameoflife-default' configuration
    screen again. Click on 'Add build step', and add a new build step to
    'Invoke top level Maven targets' (see <xref
    linkend="fig-hudson-freestyle-javadoc-build-step" />). In the Goals field,
    place <command>javadoc:javadoc</command> - this will tell Maven to
    generate the Javadoc documentation.</para>

    <figure id="fig-hudson-freestyle-javadoc-build-step">
      <title>Adding a new build step and report to generate Javadoc</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-freestyle-javadoc-build-step.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Now go to the 'Post-build Action' and tick the 'Publish Javadoc'
    checkbox. In the 'Javadoc directory' field, enter
    <filename>target/site/apidocs</filename> - this is where Maven will place
    the Javadocs it generates. Hudson may display an error message saying that
    this directory doesn't exist. Hudson is correct - this directory won't
    exist until we run the <command>javadoc:javadoc</command> goal, but since
    we haven't run this command yet we can safely ignore the message at this
    stage.</para>

    <para>If you tick 'Retain Javadoc for each successful build, Hudson will
    also keep track of the Javadocs for previous builds - not always useful,
    but it can come in handy at times.</para>

    <para>Now trigger a build manually. You can do this either from the build
    job's home page (using the "Build Now" link), or directly from the server
    home page. Once the build is finished, open the build job summary page.
    You should now see a Javadoc link featuring prominently on the screen -
    this link will open the latest version of the Javadoc documentation (see
    <xref linkend="fig-hudson-javadoc-results" />). You will also see this
    link on the build details page, where it will point to the Javadoc for
    that particular build, if you have asked Hudson to store Javadoc for each
    build.</para>

    <figure id="fig-hudson-javadoc-results">
      <title>Hudson will add a Javadoc link to your build results</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-build-with-javadoc.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>
  </sect1>

  <sect1 id="sect-first-steps-metrics">
    <title>Adding Code Coverage and other metrics</title>

    <para><indexterm>
        <primary>Code Coverage</primary>
      </indexterm>Reporting is one of Hudson's strong points. We have seen how
    easy it is to display test results and to publish Javadocs, but you can
    publish a large number of other very useful reports using Hudson's
    plugins.</para>

    <para>Plugins are another one of Hudson's selling points - there are
    plugins for doing just about anything, from integrating new build tools or
    version control systems to notification mechanisms and reporting. In
    addition, Hudson plugins are very easy to install and integrate smoothly
    into the existing Hudson architecture.</para>

    <para>To see how the plugins work, we are going to integrate code coverage
    metrics using the Cobertura plugin. Code coverage is an indication of how
    much of your application code is actually executed during your tests - it
    can be a useful tool in particular for finding areas of code that have not
    been tested by your test suites. It can also give some indication as to
    how well a team is applying good testing practices such as test-driven
    development or behaviour-driven development.</para>

    <para>Cobertura (<ulink url="http://cobertura.sourceforge.net"></ulink>)
    is an open source code coverage tool that works well with both Maven and
    Hudson. Our Maven demonstration project is already configured to record
    code coverage metrics, so all we need to do is to install the Hudson
    Cobertura plugin and generate the code coverage metrics for Hudson to
    record and display.</para>

    <figure id="fig-hudson-plugin-manager">
      <title>Hudson has a large range of plugins available</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-plugin-manager.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>To install a new plugin, go to the 'Manage Hudson' page and click on
    the 'Manage Plugins' entry. This will display a list of the available
    plugins as well as the plugins already installed on your server (see <xref
    linkend="fig-hudson-plugin-manager" />). If your build server doesn't have
    an internet connection, you can also manually install a plugin by
    downloading the plugin file elsewhere and uploading it to your Hudson
    installation (just open the 'Advanced' tab in <xref
    linkend="fig-hudson-plugin-manager" />), or by copying the plugin to the
    <filename>$HUDSON_HOME/plugins</filename> directory.</para>

    <para>In our case, we are interested in the Cobertura plugin, so go to the
    'Available' tab and scroll down until you find the 'Cobertura Plugin'
    entry in the 'Build Reports section. Click on the check box and then click
    on the 'Install' button at the bottom of the screen.</para>

    <para>This will download and install the plugin for you. Once it is done,
    you will need to restart your Hudson instance to see the fruits of your
    labor. When you have restarted Hudson, go back to the 'Manage Plugins'
    screen and click on the 'Installed' tab - there should now be a 'Cobertura
    Plugin' entry in the list of installed plugins on this page.</para>

    <para>Once you have made sure the plugin was successfully installed, go to
    the configuration page for the 'gameoflife-default' build job.</para>

    <para>To set up code coverage metrics in our project, we need to do two
    things. First we need to generate the Cobertura coverage data in an XML
    form that Hudson can use; then we need to configure Hudson to display the
    coverage reports.</para>

    <para>Our Game Of Life project already has been configured to generate XML
    code coverage reports if we ask it. All you need to do is to run
    <command>mvn cobertura:cobertura</command> to generate the reports in XML
    form. Cobertura can also generate HTML reports, but in our case we will be
    letting Hudson take care of the reporting, so we can save on build time by
    not generating the For this example, for simplicity, we will just add the
    <command>cobertura:cobertura</command> goal to the second build step (see
    <xref linkend="fig-hudson-cobertura-build-step" />). You could also add a
    new build step just for the code coverage metrics. In a real-world
    project, code quality metrics like this are typically placed in a distinct
    build job, which is run less frequently than the default build.</para>

    <figure id="fig-hudson-cobertura-build-step">
      <title>Adding another Maven goal to generating test coverage
      metrics</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-cobertura-build-step.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Next, we need to tell Hudson to keep track of our code coverage
    metrics. Scroll down to the 'Post-build Actions' section. You should see a
    new check box labeled 'Publish Cobertura Reports'. Hudson will often add
    UI elements like this when you install a new plugin. When you tick this
    box, Hudson will display the configuration options for the Cobertura
    plugin that we installed earlier (see <xref
    linkend="fig-hudson-cobertura-config" />).</para>

    <para>Like most of the code-quality related plugins in Hudson, the
    Cobertura plugin lets you fine-tune not only the way Hudson displays the
    report data, but also how it interprets the data. In the 'Coverage Metrics
    Targets' section, you can define what you consider to be the minimum
    acceptable levels of code coverage. In <xref
    linkend="fig-hudson-cobertura-config" />, we have configured Hudson to
    list any builds with less than 50% test coverage as "unstable" (indicated
    by a yellow ball), and notify the team accordingly.</para>

    <figure id="fig-hudson-cobertura-config">
      <title>Configuring the test coverage metrics in Hudson</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-config-cobertura.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>This fine-tuning often comes in handy in real-world builds. For
    example, you may want to impose a special code coverage constraint in
    release builds, to ensure high code coverage in release versions. Another
    strategy that can be useful for legacy projects is to gradually increase
    the minimum tolerated code coverage level over time. This way you can
    avoid having to retro-fit unit tests on legacy code just to raise the code
    coverage, but you do encourage all new code and bug fixes to be well
    tested.</para>

    <para>Now trigger a build manually. The first time you run the build job
    with Cobertura reporting activated, you will see coverage statistics for
    your build displayed on the build home page, along with a 'Coverage
    Report' link when you can go for more details (see <xref
    linkend="fig-hudson-initial-coverage-report" />). The Cobertura report
    shows different types of code coverage for the build we just ran. Since we
    have only run the test coverage metrics once, the coverage will be
    displayed as red and green bars.</para>

    <figure id="fig-hudson-initial-coverage-report">
      <title>Hudson displays code coverage metrics on the build home
      page</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-initial-coverage-report.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>If you click on the Coverage Report icon, you will see code coverage
    for each package in your application, and even drill down to see the code
    coverage (or lack thereof) for an individual class (see <xref
    linkend="fig-hudson-code-coverage-class" />). When you get to this level,
    Hudson displays both the overall coverage statistics for the class, and
    also highlights the lines that were executed in green, and those that
    weren't in red.</para>

    <para>This reporting gets better with time. Hudson not only reports
    metrics data for the latest build, but also keeps track of metrics over
    time, so that you can see how they evolve throughout the life of the
    project.</para>

    <para>For example, if you drill down into the coverage reports, you will
    notice that certain parts of this code are not tested (for example the
    <filename>Cell.java</filename> class in <xref
    linkend="fig-hudson-code-coverage-class" />). Let's see if we can improve
    things.</para>

    <para>Looking at this coverage report, we can see that error handling is
    poorly tested. We would probably want to ensure that our code behaves as
    expected if a user provides an incorrectly-formatted cell grid. You can
    improve things simply by adding a test like this one to the CellTest.java
    class (in the
    <filename>src/test/java/com/ciwithhudson/gameoflife/domain</filename>
    directory):</para>

    <programlisting>    @Test(expected=IllegalArgumentException.class)
    public void anInvalidCharacterShouldThrowAnException() {
        Cell.fromChar('X');
    }</programlisting>

    <para>Add this test and commit your changes to Subversion:<screen>$ svn commit -m "Added extra unit test"
Sending        src/test/java/com/ciwithhudson/gameoflife/domain/CellTest.java
Transmitting file data ..
Committed revision 8.</screen></para>

    <figure id="fig-hudson-code-coverage-class">
      <title>Hudson lets you display code coverage metrics for packages and
      classes</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-code-coverage-class.png "
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>This will trigger another build, which should result in slightly
    better code coverage statistics. You will also notice that Hudson is now
    displaying a graph of code coverage over time, not just the latest results
    (see <xref lang="" linkend="fig-hudson-code-coverage-graph" />).</para>

    <para>Note that our objective here is not to improve the code coverage
    just for the sake of improving code coverage - we are adding an extra test
    to verify some code that was not previously tested, and as a result the
    code coverage goes up. There is a subtle but important difference here -
    code coverage, as with any other metric, is very much a means to an end
    (high code quality and low maintenance costs), and not an end in
    itself.</para>

    <para>Nevertheless, metrics like this can give you a great insight into
    the health of your project, and Hudson presents them in a particularly
    accessible way.</para>

    <figure id="fig-hudson-code-coverage-graph">
      <title>Hudson also displays a graph of code coverage over time</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-code-coverage-graph.png"
                     width="4.3in" />
        </imageobject>

        <!-- v
          
-->
      </mediaobject>
    </figure>

    <para>This is just one of the code quality metrics plugins that have been
    written for Hudson. There are many more (over fifty reporting plugins
    alone at the time of writing). We'll look at some more of them in the
    chapter on Continuous Code Quality.</para>
  </sect1>

  <sect1>
    <title>Conclusion</title>

    <para>In this chapter, we have gone through what you need to know to get
    started with Hudson. You should be able to set up a new build job, and
    setting up reporting on JUnit test results and javadocs. And you have seen
    how to add a reporting pluging and keep tabs on code coverage. Well done!
    But there's still a lot more to learn about Hudson - in the following
    chapters, we will be looking at how Hudson can help you improve your build
    automation process in many other areas as well.</para>
  </sect1>
</chapter>
